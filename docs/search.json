[
  {
    "objectID": "closereads-chunk-reveal.html",
    "href": "closereads-chunk-reveal.html",
    "title": "My First Closeread",
    "section": "",
    "text": "ggplot2 allows you build up your plot bit by bit â€“ to write â€˜graphical poemsâ€™ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\nHere is a graphical poem!\n\nggplot(data = cars) + # The first declaration you typically make is the dataframe to plot\n  aes(x = speed, y = dist) + # The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance)\n  geom_point() + # Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples)\n  geom_smooth() # Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) \n\n\n\n\n\n\n\n\nCloseread helps walk people through and digest ideas suggesting a synergy with the gg world. With Closereads, maybe we can read this graphical poem â€˜aloudâ€™, and reflect on it a bit in plain language as we go. Here is a generic way to write out what closereads requires for creating plot output and referring to it.\n\ncr_last_plot_construction &lt;- ':::{focus-on=\"cr-.PLOTXXX\"}\\n.COMMENT, using `.CODE`\\n:::\\n\\n:::{#cr-.PLOTXXX}\\n```{r .PLOTXXX}\\n.LEADING\\n  .CODE\\n```\\n:::\\n'  \n\ncr_last_plot_construction |&gt; cat()\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\nThen we can look at our complete â€˜graphical poemâ€™, parse it, choreograph a line by line reveal - thanks Garrick and Emi for showing the way using powerful knitr::knit_code$get in Xaringan context! https://emitanaka.rbind.io/post/knitr-knitr-code/ At this point we arenâ€™t being really careful with code parsing or replacement; flipbookr internals has some nicer parsing that might be useable and allow more incremental reveals in other contexts like datamanipulation and table creation. In contrast to the full reiterated code that we show in flipbookr w/ Xaringan w/ plot, weâ€™ll use last_plot() + new_code() below. It just feels like a better fit.\n\nknitr::knit_code$get(\"walkthrough\") |&gt;\n  tibble(code_raw = _) |&gt;\n  mutate(comment = str_extract(code_raw, \"#.+$\")) |&gt;\n  mutate(comment = str_remove(comment, \"#\")) |&gt;\n  mutate(code = str_remove(code_raw, \"\\\\+ #.+$|#.+$\")) |&gt;\n  mutate(index = row_number()) |&gt;\n  mutate(plot_name = paste(\"walkthrough\", sep = \"-\", index)) |&gt;\n  mutate(to_cr = cr_last_plot_construction) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".PLOTXXX\", plot_name)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".COMMENT\", comment)) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".CODE\", code)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".LEADING\", ifelse(index == 1, \"\", \"last_plot() +\"))) |&gt;\n  pull(to_cr) -&gt; \nto_closeread\n\nto_closeread\n\n[1] \":::{focus-on=\\\"cr-walkthrough-1\\\"}\\n The first declaration you typically make is the dataframe to plot, using `ggplot(data = cars) `\\n:::\\n\\n:::{#cr-walkthrough-1}\\n```{r walkthrough-1}\\n\\n  ggplot(data = cars) \\n```\\n:::\\n\"                                                                                                           \n[2] \":::{focus-on=\\\"cr-walkthrough-2\\\"}\\n The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using `  aes(x = speed, y = dist) `\\n:::\\n\\n:::{#cr-walkthrough-2}\\n```{r walkthrough-2}\\nlast_plot() +\\n    aes(x = speed, y = dist) \\n```\\n:::\\n\" \n[3] \":::{focus-on=\\\"cr-walkthrough-3\\\"}\\n Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using `  geom_point() `\\n:::\\n\\n:::{#cr-walkthrough-3}\\n```{r walkthrough-3}\\nlast_plot() +\\n    geom_point() \\n```\\n:::\\n\"                             \n[4] \":::{focus-on=\\\"cr-walkthrough-4\\\"}\\n Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using `  geom_smooth() `\\n:::\\n\\n:::{#cr-walkthrough-4}\\n```{r walkthrough-4}\\nlast_plot() +\\n    geom_smooth() \\n```\\n:::\\n\"\n\n\nOkay, ready for the closeread demonstration! (Comparing flipbookr/xaringan implementation what we are doing here, thereâ€™s probably greater focus on narration.) Weâ€™ll use knitr::knit() inline to get this done - paste(knitr::knit(text = to_closeread, quiet = F), collapse = \"\\n\\n\")\n\n\n\n\nThe first declaration you typically make is the dataframe to plot, using ggplot(data = cars)\n\n\n\n\nThe second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using aes(x = speed, y = dist)\n\n\n\n\nThen youâ€™ll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using geom_point()\n\n\n\n\nFinally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using geom_smooth()\n\n\n\n\n\n\n\n  ggplot(data = cars) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(x = speed, y = dist) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_point() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_smooth()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Everyday ggplot2 extension: sublayer modularity ðŸ«–",
    "section": "",
    "text": "Welcome to ggplot2 extenders/ggplot2 extension club. This forum exists to facilitate conversations about experiences with extension. We like to talk about motivations, challenges, equivocations â€” in general, extension journeys!\nOur main activities are meetings and discussions.\nInterested in joining us? Please leave your contact info here and let us know a little about your interest in ggplot2 extension so we can be in touch!\nNote that the extension ecosystem is extensive and other initiatives exist to support extenders, check out some other resources."
  },
  {
    "objectID": "ggplot2-sublayer-modularity.html",
    "href": "ggplot2-sublayer-modularity.html",
    "title": "ggplot2 sublayer modularity",
    "section": "",
    "text": "If you are a fan of ggplot2, you are probably also a fan of â€˜layerâ€™ functions geom_*() and stat_*().\n\n\n\n\nImportant clarification before we begin: Sometimes all the ggplot2 functions are referred to as ggplot2 â€˜layersâ€™, i.e.Â scales_*(), coord_*(), etc as in â€˜build up your plot layer-by-layerâ€™. *\n\n\n\n\nBut we are using the word in the narrower, sense used in the ggplot2 documentation.\n\n\n\n\nMaybe you get giddy thinking about geom_bump(), geom_ridgeline(), or classic geom_histogram()?\n\n\n\n\nWell-composed geom_*()s and stat_*()s (i.e.Â layer) make for more fluid analytic discovery.\n\n\n\n\nBut what elements constitute a layer function?\n\n\n\n\nLetâ€™s look at geom_bar() to get a feel for what layer composition means.\nIn this plot specification, geom_bar() counts the number of observations that are of each value of x (cut).\n\n\n\n\nThere are actually three main characters in every geom_() or stat_().\n\n\n\n\nThey are geom, stat, and position.\n\n\n\n\nIn geom_bar() the geom is fixed, but stat and position are adjustable. You can see that their defaults are \"count\" and \"stack\" in the functionâ€™s definition.\n\n\n\n\nAnd instead of using convenient geom_bar(), we can use the more generic layer() function - which is actually used under the hood to define all geom_*() and stat_*() functions.\n\n\n\n\nWe can reproduce `geom_bar()`â€˜s behavior with layer(), but we must provide all three â€™control operatorsâ€™:layer(geom = \"bar\", stat = \"count\", position = \"stack\").\n\n\n\n\nOr, equivalently, we can simply name the underlying ggproto objects, GeomBar and StatCount in our case, and the position function, position_stack() .\n\n\n\n\nReiteration: There are actually â€˜control operatorsâ€™ that define the geom_*() and stat_*() user-facing function. Geoms, Stats, and position_*().\n\n\n\n\nYou can refer to them indirectly by quoting their stem, layer(geom = \"bar\", stat = \"count\", position = \"stack\").\n\n\n\n\nOr use the ggproto objects and position function directly, layer(geom = GeomBar, stat = StatCount, position = position_stack())\n\n\n\n\nFocus: Lets look at one â€˜control operatorâ€™, the Stat, more closely.\n\n\n\n\nStats themselves have a number of control elements.\n\n\n\n\nIt transforms plot input data before it is passed off to be rendered.\nStatâ€™s computation is defined in the compute slots.\nAnd in StatCount, compute is done group-wise, so compute_group() defines StatCountâ€™s data transformation.\n\n\n\n\nWe can get a sense of StatCount$compute_groupâ€™s behavior by using on our data.\nFirst, we use select() to make the data look as it would inside of the ggplot2 plotting environment â€” this mirrors the aes(x = cut) mapping declaration.\nThen we see that the data is collapsed by x, and count and prop variables are produced.\n\n\n\n\nWe can think about StatCountâ€™s job as doing some computation that the user might otherwise be responsible for.\n\n\n\n\nWe use StatCount$compute_group() to manually do this computation for us, in conjunction with StatIdentity (leaves data alone) in layer to show this work explicitly.\n\n\n\n\nKey point: We might think Statâ€™s job as lightening the analystâ€™s load - doing computation that the user would otherwise need to do for before plotting.\n\n\n\n\nOne final question you might have is â€™how exactly is the height of the bar, y, communicated to the ggplot2 system? Why does that just work?\n\n\n\n\nThis is managed by the default_aes specification for StatCount.\nBecause there is no variable mapped to y in our plot specification, y position defaults to after_stat(count), in other words the computed variable count that is available after the StatCount computation is done!\n\n\n\n\nAnd it is good to do a little mix-and-match thinking to get a further feel for StatCount. Which of the following plots will have identical outputs?\n\n\n\n\nIs this what you anticipated?\n\n\n\n\nAbove, weâ€™ve had an outside-in look at some aspects of â€˜sublayer modularityâ€™.\nTo get an inside-out look â€” building up your own Stat from scratch â€” you might have a look at â€˜easy geom recipesâ€™ or by joining ggplot2 extenders club\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_bar\n\nfunction (mapping = NULL, data = NULL, stat = \"count\", position = \"stack\", \n    ..., just = 0.5, na.rm = FALSE, orientation = NA, show.legend = NA, \n    inherit.aes = TRUE) \n{\n    layer(data = data, mapping = mapping, stat = stat, geom = GeomBar, \n        position = position, show.legend = show.legend, inherit.aes = inherit.aes, \n        params = list2(just = just, na.rm = na.rm, orientation = orientation, \n            ...))\n}\n&lt;bytecode: 0x7fe7c772e5b8&gt;\n&lt;environment: namespace:ggplot2&gt;\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  layer(geom = \"bar\", stat = \"count\", position = \"stack\")\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, stat = StatCount, position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatCount |&gt; names()\n\n[1] \"default_aes\"   \"extra_params\"  \"super\"         \"compute_group\"\n[5] \"required_aes\"  \"setup_params\"  \"dropped_aes\"  \n\n\n\n\n\nStatCount$compute_group\n\n&lt;ggproto method&gt;\n  &lt;Wrapper function&gt;\n    function (...) \ncompute_group(..., self = self)\n\n  &lt;Inner function (f)&gt;\n    function (self, data, scales, width = NULL, flipped_aes = FALSE) \n{\n    data &lt;- flip_data(data, flipped_aes)\n    x &lt;- data$x\n    weight &lt;- data$weight %||% rep(1, length(x))\n    count &lt;- as.vector(rowsum(weight, x, na.rm = TRUE))\n    bars &lt;- data_frame0(count = count, prop = count/sum(abs(count)), \n        x = sort(unique0(x)), width = width, flipped_aes = flipped_aes, \n        .size = length(count))\n    flip_data(bars, flipped_aes)\n}\n\n\n\n\n\nlibrary(dplyr)\n\ndiamonds |&gt; \n  select(x = cut) |&gt;\n  StatCount$compute_group() \n\n  count       prop         x flipped_aes\n1  1610 0.02984798      Fair       FALSE\n2  4906 0.09095291      Good       FALSE\n3 12082 0.22398962 Very Good       FALSE\n4 13791 0.25567297   Premium       FALSE\n5 21551 0.39953652     Ideal       FALSE\n\n\n\n\n\nprecomputation &lt;- diamonds |&gt; \n  select(x = cut) |&gt;\n  StatCount$compute_group()\n\nprecomputation |&gt;\n  ggplot() + \n  aes(x = x, y = count) + \n  layer(geom = GeomBar, \n        stat = StatIdentity, \n        position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatCount$default_aes\n\nAesthetic mapping: \n* `x`      -&gt; `after_stat(count)`\n* `y`      -&gt; `after_stat(count)`\n* `weight` -&gt; 1\n\nggplot(data = diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, \n        stat = StatCount, \n        position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\np1 &lt;- ggplot(data = diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, \n        stat = StatCount, \n        position = position_stack())\n\np2 &lt;- p1 + geom_point(stat = StatCount)\n\np3 &lt;- p1 + stat_count(geom = GeomPoint)\n\np4 &lt;- p1 + geom_label(stat = StatCount, \n                      aes(label = after_stat(count)))\n\np5 &lt;- p1 + stat_count(geom = GeomText, \n                      aes(label = after_stat(count)), \n                      vjust = 1)\n\n\n\n\nlibrary(patchwork)\np2+ p3 + p4 + p5"
  },
  {
    "objectID": "ggprefixes.html",
    "href": "ggprefixes.html",
    "title": "Who are the ggplot2 extenders?",
    "section": "",
    "text": "user_repo_fun &lt;- read_csv(\"https://raw.githubusercontent.com/EvaMaeRey/mytidytuesday/refs/heads/main/2024-11-19-gg-prefixes/exported_funs_exts_ggplot2_tidyverse_org.csv\") %&gt;% \n  mutate(prefix_short = fun_exported |&gt; str_extract(\".*?_\")) %&gt;% \n  mutate(prefix_long = fun_exported |&gt; str_extract(\".+_\"))\n\nsample_n(user_repo_fun, 10)\n\n# A tibble: 10 Ã— 5\n   user           repo      fun_exported                prefix_short prefix_long\n   &lt;chr&gt;          &lt;chr&gt;     &lt;chr&gt;                       &lt;chr&gt;        &lt;chr&gt;      \n 1 road2stat      ggsci     \"scale_fill_ucscgb\"         scale_       scale_fill_\n 2 thomasp85      gganimate \"transition_time\"           transition_  transition_\n 3 shikokuchuo    ichimoku  \"oanda_chart\"               oanda_       oanda_     \n 4 jrnold         ggthemes  \"tableau_seq_gradient_pal\"  tableau_     tableau_seâ€¦\n 5 jbengler       tidyplots \"\\\"%&gt;%\\\"\"                   &lt;NA&gt;         &lt;NA&gt;       \n 6 davidgohel     ggiraph   \"scale_linetype_interactivâ€¦ scale_       scale_lineâ€¦\n 7 ggobi          ggally    \"model_beta_variables\"      model_       model_beta_\n 8 malcolmbarrett ggdag     \"label\"                     &lt;NA&gt;         &lt;NA&gt;       \n 9 jhrcook        ggasym    \"scale_fill_br_gradient\"    scale_       scale_fillâ€¦\n10 teunbrand      legendry  \"GuideColourbar\"            &lt;NA&gt;         &lt;NA&gt;       \n\n\n\ndata_filter &lt;- function(.keep, .by) {\n  structure(list(keep_specification = rlang::enquo(.keep), \n                 by_specification = rlang::enquo(.by)), \n            class = \"filterobs\")\n}\n\nggplot_add.filterobs &lt;- function(object, plot, object_name) {\n  \n  new_data &lt;- dplyr::filter(plot$data, \n                            !!object$keep_specification, \n                            .by = !!object$by_specification)\n  plot$data &lt;- new_data\n  plot\n\n}\n\nggplot2 allows you build up your plot bit by bit â€“ to write â€˜graphical poemsâ€™ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\n\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\n\n\n\n\nthe data frame to be plotted is all the exported functions from the , using ggplot(data = user_repo_fun)\n\n\n\n\nletâ€™s look at a count of all the exported functions first, using aes(id = \"All exportedn functions\")\n\n\n\n\nUsing circlepacking, we automatically have circles size representing the number of observation, i.e.Â exported functions, using ggcirclepack::geom_circlepack()\n\n\n\n\nOf course this is hard to interpret without some kind of label. We use geom_circplepack_text to do this for us, using ggcirclepack::geom_circlepack_text()\n\n\n\n\nweâ€™ll add a theme, using ggchalkboard:::theme_glassboard()\n\n\n\n\nAnd remove axesâ€¦ , using theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())\n\n\n\n\nand lets square up the circles, using coord_equal()\n\n\n\n\nFirst we ask what packages - github repository names - are present, using aes(id = repo)\n\n\n\n\nThen letâ€™s look at who is writing these exported functions, using aes(id = user)\n\n\n\n\nAnd we can look at what types of functions are exported, by looking at prefixes, using aes(id = prefix_short)\n\n\n\n\nDisaggregating a little, to longer prefixes like scale_color, we get a more granular look at exported function types, using aes(id = prefix_long)\n\n\n\n\nand we filter more popular prefixes, using data_filter(n() &gt; 60 & !is.na(prefix_long), .by = prefix_long)\n\n\n\n\nand break up our plot space by these prefixes, using facet_wrap(~prefix_long)\n\n\n\n\ngf isnâ€™t really a in-grammar prefix, using data_filter(prefix_long != \"gf_\")\n\n\n\n\nletâ€™s look at top prefixes by user, using aes(id = user)\n\n\n\n\nand look at the prolific authors in each of these areas, using data_filter(n() &gt;= 10, .by = c(user, prefix_long))\n\n\n\n\n\n\n\n  ggplot(data = user_repo_fun) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = \"All exportedn functions\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggcirclepack::geom_circlepack() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggcirclepack::geom_circlepack_text() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggchalkboard:::theme_glassboard() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    coord_equal() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = repo) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = user) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = prefix_short) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = prefix_long) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_filter(n() &gt; 60 & !is.na(prefix_long), .by = prefix_long) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    facet_wrap(~prefix_long) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_filter(prefix_long != \"gf_\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = user) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_filter(n() &gt;= 10, .by = c(user, prefix_long)) \n\n\n\n\n\n\n\n\n\n\n\n\n\nlast_plot()$plot_data\n\nNULL\n\n\nHere is the complete graphical poem!\n\nggplot(data = user_repo_fun) + # the data frame to be plotted is all the exported functions from the \n  aes(id = \"All exported\\n functions\") + # let's look at a count of all the exported functions first\n  ggcirclepack::geom_circlepack() + # Using circlepacking, we automatically have circles size representing the number of observation, i.e. exported functions\n  ggcirclepack::geom_circlepack_text() + # Of course this is hard to interpret without some kind of label.  We use geom_circplepack_text to do this for us\n  ggchalkboard:::theme_glassboard() + # we'll add a theme\n  theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) + # And remove axes... \n  coord_equal() + # and lets square up the circles\n  aes(id = repo) + # First we ask what packages - github repository names - are present\n  aes(id = user) + # Then let's look at who is writing these exported functions\n  aes(id = prefix_short) + # And we can look at what types of functions are exported, by looking at prefixes\n  aes(id = prefix_long) + # Disaggregating a little, to longer prefixes like scale_color, we get a more granular look at exported function types\n  data_filter(n() &gt; 60 & !is.na(prefix_long), .by = prefix_long) + # and we filter more popular prefixes\n  facet_wrap(~prefix_long) + # and break up our plot space by these prefixes\n  data_filter(prefix_long != \"gf_\") + #gf isn't really a in-grammar prefix\n  aes(id = user) + # let's look at top prefixes by user\n  data_filter(n() &gt;= 10, .by = c(user, prefix_long)) # and look at the prolific authors in each of these areas"
  },
  {
    "objectID": "ggregion.html",
    "href": "ggregion.html",
    "title": "My First Closeread",
    "section": "",
    "text": "ggplot2 allows you build up your plot bit by bit â€“ to write â€˜graphical poemsâ€™ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\nHere is a graphical poem!\n\nggplot(data = cars) + # The first declaration you typically make is the dataframe to plot\n  aes(x = speed, y = dist) + # The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance)\n  geom_point() + # Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples)\n  geom_smooth() # Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) \n\n\n\n\n\n\n\n\nCloseread helps walk people through and digest ideas suggesting a synergy with the gg world. With Closereads, maybe we can read this graphical poem â€˜aloudâ€™, and reflect on it a bit in plain language as we go. Here is a generic way to write out what closereads requires for creating plot output and referring to it.\n\ncr_last_plot_construction &lt;- ':::{focus-on=\"cr-.PLOTXXX\"}\\n.COMMENT, using `.CODE`\\n:::\\n\\n:::{#cr-.PLOTXXX}\\n```{r .PLOTXXX}\\n.LEADING\\n  .CODE\\n```\\n:::\\n'  \n\ncr_last_plot_construction |&gt; cat()\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\nThen we can look at our complete â€˜graphical poemâ€™, parse it, choreograph a line by line reveal - thanks Garrick and Emi for showing the way using powerful knitr::knit_code$get in Xaringan context! https://emitanaka.rbind.io/post/knitr-knitr-code/ At this point we arenâ€™t being really careful with code parsing or replacement; flipbookr internals has some nicer parsing that might be useable and allow more incremental reveals in other contexts like datamanipulation and table creation. In contrast to the full reiterated code that we show in flipbookr w/ Xaringan w/ plot, weâ€™ll use last_plot() + new_code() below. It just feels like a better fit.\n\nknitr::knit_code$get(\"walkthrough\") |&gt;\n  tibble(code_raw = _) |&gt;\n  mutate(comment = str_extract(code_raw, \"#.+$\")) |&gt;\n  mutate(comment = str_remove(comment, \"#\")) |&gt;\n  mutate(code = str_remove(code_raw, \"\\\\+ #.+$|#.+$\")) |&gt;\n  mutate(index = row_number()) |&gt;\n  mutate(plot_name = paste(\"walkthrough\", sep = \"-\", index)) |&gt;\n  mutate(to_cr = cr_last_plot_construction) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".PLOTXXX\", plot_name)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".COMMENT\", comment)) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".CODE\", code)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".LEADING\", ifelse(index == 1, \"\", \"last_plot() +\"))) |&gt;\n  pull(to_cr) -&gt; \nto_closeread\n\nto_closeread\n\n[1] \":::{focus-on=\\\"cr-walkthrough-1\\\"}\\n The first declaration you typically make is the dataframe to plot, using `ggplot(data = cars) `\\n:::\\n\\n:::{#cr-walkthrough-1}\\n```{r walkthrough-1}\\n\\n  ggplot(data = cars) \\n```\\n:::\\n\"                                                                                                           \n[2] \":::{focus-on=\\\"cr-walkthrough-2\\\"}\\n The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using `  aes(x = speed, y = dist) `\\n:::\\n\\n:::{#cr-walkthrough-2}\\n```{r walkthrough-2}\\nlast_plot() +\\n    aes(x = speed, y = dist) \\n```\\n:::\\n\" \n[3] \":::{focus-on=\\\"cr-walkthrough-3\\\"}\\n Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using `  geom_point() `\\n:::\\n\\n:::{#cr-walkthrough-3}\\n```{r walkthrough-3}\\nlast_plot() +\\n    geom_point() \\n```\\n:::\\n\"                             \n[4] \":::{focus-on=\\\"cr-walkthrough-4\\\"}\\n Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using `  geom_smooth() `\\n:::\\n\\n:::{#cr-walkthrough-4}\\n```{r walkthrough-4}\\nlast_plot() +\\n    geom_smooth() \\n```\\n:::\\n\"\n\n\nOkay, ready for the closeread demonstration! (Comparing flipbookr/xaringan implementation what we are doing here, thereâ€™s probably greater focus on narration.) Weâ€™ll use knitr::knit() inline to get this done - paste(knitr::knit(text = to_closeread, quiet = F), collapse = \"\\n\\n\")\n\n\n\n\nThe first declaration you typically make is the dataframe to plot, using ggplot(data = cars)\n\n\n\n\nThe second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using aes(x = speed, y = dist)\n\n\n\n\nThen youâ€™ll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using geom_point()\n\n\n\n\nFinally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using geom_smooth()\n\n\n\n\n\n\n\n  ggplot(data = cars) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(x = speed, y = dist) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_point() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_smooth()"
  }
]