[
  {
    "objectID": "closereads-chunk-reveal.html",
    "href": "closereads-chunk-reveal.html",
    "title": "My First Closeread",
    "section": "",
    "text": "ggplot2 allows you build up your plot bit by bit â€“ to write â€˜graphical poemsâ€™ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\nHere is a graphical poem!\n\nggplot(data = cars) + # The first declaration you typically make is the dataframe to plot\n  aes(x = speed, y = dist) + # The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance)\n  geom_point() + # Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples)\n  geom_smooth() # Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) \n\n\n\n\n\n\n\n\nCloseread helps walk people through and digest ideas suggesting a synergy with the gg world. With Closereads, maybe we can read this graphical poem â€˜aloudâ€™, and reflect on it a bit in plain language as we go. Here is a generic way to write out what closereads requires for creating plot output and referring to it.\n\ncr_last_plot_construction &lt;- ':::{focus-on=\"cr-.PLOTXXX\"}\\n.COMMENT, using `.CODE`\\n:::\\n\\n:::{#cr-.PLOTXXX}\\n```{r .PLOTXXX}\\n.LEADING\\n  .CODE\\n```\\n:::\\n'  \n\ncr_last_plot_construction |&gt; cat()\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\nThen we can look at our complete â€˜graphical poemâ€™, parse it, choreograph a line by line reveal - thanks Garrick and Emi for showing the way using powerful knitr::knit_code$get in Xaringan context! https://emitanaka.rbind.io/post/knitr-knitr-code/ At this point we arenâ€™t being really careful with code parsing or replacement; flipbookr internals has some nicer parsing that might be useable and allow more incremental reveals in other contexts like datamanipulation and table creation. In contrast to the full reiterated code that we show in flipbookr w/ Xaringan w/ plot, weâ€™ll use last_plot() + new_code() below. It just feels like a better fit.\n\nknitr::knit_code$get(\"walkthrough\") |&gt;\n  tibble(code_raw = _) |&gt;\n  mutate(comment = str_extract(code_raw, \"#.+$\")) |&gt;\n  mutate(comment = str_remove(comment, \"#\")) |&gt;\n  mutate(code = str_remove(code_raw, \"\\\\+ #.+$|#.+$\")) |&gt;\n  mutate(index = row_number()) |&gt;\n  mutate(plot_name = paste(\"walkthrough\", sep = \"-\", index)) |&gt;\n  mutate(to_cr = cr_last_plot_construction) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".PLOTXXX\", plot_name)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".COMMENT\", comment)) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".CODE\", code)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".LEADING\", ifelse(index == 1, \"\", \"last_plot() +\"))) |&gt;\n  pull(to_cr) -&gt; \nto_closeread\n\nto_closeread\n\n[1] \":::{focus-on=\\\"cr-walkthrough-1\\\"}\\n The first declaration you typically make is the dataframe to plot, using `ggplot(data = cars) `\\n:::\\n\\n:::{#cr-walkthrough-1}\\n```{r walkthrough-1}\\n\\n  ggplot(data = cars) \\n```\\n:::\\n\"                                                                                                           \n[2] \":::{focus-on=\\\"cr-walkthrough-2\\\"}\\n The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using `  aes(x = speed, y = dist) `\\n:::\\n\\n:::{#cr-walkthrough-2}\\n```{r walkthrough-2}\\nlast_plot() +\\n    aes(x = speed, y = dist) \\n```\\n:::\\n\" \n[3] \":::{focus-on=\\\"cr-walkthrough-3\\\"}\\n Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using `  geom_point() `\\n:::\\n\\n:::{#cr-walkthrough-3}\\n```{r walkthrough-3}\\nlast_plot() +\\n    geom_point() \\n```\\n:::\\n\"                             \n[4] \":::{focus-on=\\\"cr-walkthrough-4\\\"}\\n Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using `  geom_smooth() `\\n:::\\n\\n:::{#cr-walkthrough-4}\\n```{r walkthrough-4}\\nlast_plot() +\\n    geom_smooth() \\n```\\n:::\\n\"\n\n\nOkay, ready for the closeread demonstration! (Comparing flipbookr/xaringan implementation what we are doing here, thereâ€™s probably greater focus on narration.) Weâ€™ll use knitr::knit() inline to get this done - paste(knitr::knit(text = to_closeread, quiet = F), collapse = \"\\n\\n\")\n\n\n\n\nThe first declaration you typically make is the dataframe to plot, using ggplot(data = cars)\n\n\n\n\nThe second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using aes(x = speed, y = dist)\n\n\n\n\nThen youâ€™ll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using geom_point()\n\n\n\n\nFinally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using geom_smooth()\n\n\n\n\n\n\n\n  ggplot(data = cars) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(x = speed, y = dist) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_point() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_smooth()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggplot2 extenders ðŸ«–",
    "section": "",
    "text": "Welcome to ggplot2 extenders/ggplot2 extension club. This forum exists to facilitate conversations about experiences with extension. We like to talk about motivations, challenges, equivocations â€” in general, extension journeys!\nOur main activities are meetings and discussions.\nInterested in joining us? Please leave your contact info here and let us know a little about your interest in ggplot2 extension so we can be in touch!\nNote that the extension ecosystem is extensive and other initiatives exist to support extenders, check out some other resources."
  },
  {
    "objectID": "ggplot2-sublayer-modularity.html",
    "href": "ggplot2-sublayer-modularity.html",
    "title": "ggplot2 sublayer modularity",
    "section": "",
    "text": "If you are a fan of ggplot2, you are probably also a fan of â€˜layerâ€™ functions: geom_* and stat_* functions.\n\n\n\n\nMaybe you are giddy when you think about geom_bump? Do you love to layer on a good geom_ridgelines? Is rendering classic geom_histogram just kind of exciting?\n\n\n\n\nWell-composed layers, (choice in sublayer modules) affords greater fluidity for ggplot2 users and faster analytic discovery. But what elements constitute a layer function?\n\n\n\n\nLetâ€™s look at geom_bar() composition to get a feel for what layer composition means.\n\n\n\n\nYou might be aware that controlling each layer are three main elements. We can express the layer geom_bar() in terms of the component elements too using the layer() function â€¦ we can translate geom_bar() to layer(geom = \"bar\", stat = \"count\", position = \"stack\")\n\n\n\n\nOr we can simply name the ggproto object or function which the quoted text in the variant above refers too: GeomBar, StatCount, and position_stack() are at work in the default settings for geom_bar().\n\n\n\n\nMain point: There are three main â€˜control operatorsâ€™ for every layer call: geom, stat, and position. You can refer to them indirectly by quoting their stem, layer(geom = \"bar\", stat = \"count\", position = \"stack\"), or use them directly, layer(geom = GeomBar, stat = StatCount, position = position_stack())\n\n\n\n\nFocus: Lets look at the second â€˜control operatorâ€™ Stat, more closely.\n\n\n\n\nStats themselves have a number of control elements.\n\n\n\n\nCritically, it can transform input plot input data before it is passed off to be rendered. Compute is defined in the compute slots, and in StatCount, compute is done group-wise, so compute_group() defines StatCountâ€™s data transformation.\n\n\n\n\nWe can get a sense of StatCount$compute_groupâ€™s behavior by using on our data. First, we use select() to make the data look as it would inside of the ggplot2 plotting environment. Then we see that the data is collapsed by x, and count and prop variables are produced.\n\n\n\n\nWe can think about StatCountâ€™s job as doing some pre-computation that the user might otherwise be responsible for. We use StatCount$compute_group() to manually do this computation for us, in conjunction with StatIdentity in layer (leaves data alone) to explicitly show this work.\n\n\n\n\nKey point: We might think Statâ€™s job as doing heavy lifting - some pre-computation that the user might otherwise be responsible for.\n\n\n\n\nOne final question you might have is â€˜how do we get the height of the bar, y? Why does that â€™just workâ€™?\n\n\n\n\nThis is managed by the default_aes specification for StatCount. Because there is no variable mapped to y in our plot specification, y position default to after_stat(count), the count variable that results from the StatCount computation.\n\n\n\n\nAnd it is good to do a little mix and match thinking to get a further feel for StatCount. Which of the following plots will have identical outputs?\n\n\n\n\nIs this what you anticipated?\n\n\n\n\nAbove, weâ€™ve had an outside-in look at some aspects of â€˜sublayer modularityâ€™. To get an inside-out look â€“ building up your own Stat â€“ you might have a look at â€˜easy geom recipesâ€™ or by joining ggplot2 extenders club\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  layer(geom = \"bar\", stat = \"count\", position = \"stack\")\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, stat = StatCount, position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatCount$compute_group\n\n&lt;ggproto method&gt;\n  &lt;Wrapper function&gt;\n    function (...) \ncompute_group(..., self = self)\n\n  &lt;Inner function (f)&gt;\n    function (self, data, scales, width = NULL, flipped_aes = FALSE) \n{\n    data &lt;- flip_data(data, flipped_aes)\n    x &lt;- data$x\n    weight &lt;- data$weight %||% rep(1, length(x))\n    count &lt;- as.vector(rowsum(weight, x, na.rm = TRUE))\n    bars &lt;- data_frame0(count = count, prop = count/sum(abs(count)), \n        x = sort(unique0(x)), width = width, flipped_aes = flipped_aes, \n        .size = length(count))\n    flip_data(bars, flipped_aes)\n}\n\n\n\n\n\nlibrary(dplyr)\n\ndiamonds |&gt; \n  select(x = cut) |&gt;\n  StatCount$compute_group() \n\n  count       prop         x flipped_aes\n1  1610 0.02984798      Fair       FALSE\n2  4906 0.09095291      Good       FALSE\n3 12082 0.22398962 Very Good       FALSE\n4 13791 0.25567297   Premium       FALSE\n5 21551 0.39953652     Ideal       FALSE\n\n\n\n\n\nprecomputation &lt;- diamonds |&gt; \n  select(x = cut) |&gt;\n  StatCount$compute_group()\n\nprecomputation |&gt;\n  ggplot() + \n  aes(x = x, y = count) + \n  layer(geom = GeomBar, \n        stat = StatIdentity, \n        position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatCount$default_aes\n\nAesthetic mapping: \n* `x`      -&gt; `after_stat(count)`\n* `y`      -&gt; `after_stat(count)`\n* `weight` -&gt; 1\n\nggplot(data = diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, \n        stat = StatCount, \n        position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\np1 &lt;- ggplot(data = diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, \n        stat = StatCount, \n        position = position_stack())\n\np2 &lt;- p1 + geom_point(stat = StatCount)\n\np3 &lt;- p1 + stat_count(geom = GeomPoint)\n\np4 &lt;- p1 + geom_label(stat = StatCount, \n                      aes(label = after_stat(count)))\n\np5 &lt;- p1 + stat_count(geom = GeomText, \n                      aes(label = after_stat(count)), \n                      vjust = 1)\n\n\n\n\nlibrary(patchwork)\np2+ p3 + p4 + p5"
  }
]