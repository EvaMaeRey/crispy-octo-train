[
  {
    "objectID": "closereads-chunk-reveal.html",
    "href": "closereads-chunk-reveal.html",
    "title": "My First Closeread",
    "section": "",
    "text": "ggplot2 allows you build up your plot bit by bit â€“ to write â€˜graphical poemsâ€™ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\nHere is a graphical poem!\n\nggplot(data = cars) + # The first declaration you typically make is the dataframe to plot\n  aes(x = speed, y = dist) + # The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance)\n  geom_point() + # Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples)\n  geom_smooth() # Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) \n\n\n\n\n\n\n\n\nCloseread helps walk people through and digest ideas suggesting a synergy with the gg world. With Closereads, maybe we can read this graphical poem â€˜aloudâ€™, and reflect on it a bit in plain language as we go. Here is a generic way to write out what closereads requires for creating plot output and referring to it.\n\ncr_last_plot_construction &lt;- ':::{focus-on=\"cr-.PLOTXXX\"}\\n.COMMENT, using `.CODE`\\n:::\\n\\n:::{#cr-.PLOTXXX}\\n```{r .PLOTXXX}\\n.LEADING\\n  .CODE\\n```\\n:::\\n'  \n\ncr_last_plot_construction |&gt; cat()\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\nThen we can look at our complete â€˜graphical poemâ€™, parse it, choreograph a line by line reveal - thanks Garrick and Emi for showing the way using powerful knitr::knit_code$get in Xaringan context! https://emitanaka.rbind.io/post/knitr-knitr-code/ At this point we arenâ€™t being really careful with code parsing or replacement; flipbookr internals has some nicer parsing that might be useable and allow more incremental reveals in other contexts like datamanipulation and table creation. In contrast to the full reiterated code that we show in flipbookr w/ Xaringan w/ plot, weâ€™ll use last_plot() + new_code() below. It just feels like a better fit.\n\nknitr::knit_code$get(\"walkthrough\") |&gt;\n  tibble(code_raw = _) |&gt;\n  mutate(comment = str_extract(code_raw, \"#.+$\")) |&gt;\n  mutate(comment = str_remove(comment, \"#\")) |&gt;\n  mutate(code = str_remove(code_raw, \"\\\\+ #.+$|#.+$\")) |&gt;\n  mutate(index = row_number()) |&gt;\n  mutate(plot_name = paste(\"walkthrough\", sep = \"-\", index)) |&gt;\n  mutate(to_cr = cr_last_plot_construction) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".PLOTXXX\", plot_name)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".COMMENT\", comment)) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".CODE\", code)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".LEADING\", ifelse(index == 1, \"\", \"last_plot() +\"))) |&gt;\n  pull(to_cr) -&gt; \nto_closeread\n\nto_closeread\n\n[1] \":::{focus-on=\\\"cr-walkthrough-1\\\"}\\n The first declaration you typically make is the dataframe to plot, using `ggplot(data = cars) `\\n:::\\n\\n:::{#cr-walkthrough-1}\\n```{r walkthrough-1}\\n\\n  ggplot(data = cars) \\n```\\n:::\\n\"                                                                                                           \n[2] \":::{focus-on=\\\"cr-walkthrough-2\\\"}\\n The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using `  aes(x = speed, y = dist) `\\n:::\\n\\n:::{#cr-walkthrough-2}\\n```{r walkthrough-2}\\nlast_plot() +\\n    aes(x = speed, y = dist) \\n```\\n:::\\n\" \n[3] \":::{focus-on=\\\"cr-walkthrough-3\\\"}\\n Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using `  geom_point() `\\n:::\\n\\n:::{#cr-walkthrough-3}\\n```{r walkthrough-3}\\nlast_plot() +\\n    geom_point() \\n```\\n:::\\n\"                             \n[4] \":::{focus-on=\\\"cr-walkthrough-4\\\"}\\n Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using `  geom_smooth() `\\n:::\\n\\n:::{#cr-walkthrough-4}\\n```{r walkthrough-4}\\nlast_plot() +\\n    geom_smooth() \\n```\\n:::\\n\"\n\n\nOkay, ready for the closeread demonstration! (Comparing flipbookr/xaringan implementation what we are doing here, thereâ€™s probably greater focus on narration.) Weâ€™ll use knitr::knit() inline to get this done - paste(knitr::knit(text = to_closeread, quiet = F), collapse = \"\\n\\n\")\n\n\n\n\nThe first declaration you typically make is the dataframe to plot, using ggplot(data = cars)\n\n\n\n\nThe second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using aes(x = speed, y = dist)\n\n\n\n\nThen youâ€™ll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using geom_point()\n\n\n\n\nFinally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using geom_smooth()\n\n\n\n\n\n\n\n  ggplot(data = cars) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(x = speed, y = dist) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_point() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_smooth()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Everyday ggplot2 closereads ðŸ«–",
    "section": "",
    "text": "Welcome to ggplot2 extenders/ggplot2 extension club. This forum exists to facilitate conversations about experiences with extension. We like to talk about motivations, challenges, equivocations â€” in general, extension journeys!\nOur main activities are meetings and discussions.\nInterested in joining us? Please leave your contact info here and let us know a little about your interest in ggplot2 extension so we can be in touch!\nNote that the extension ecosystem is extensive and other initiatives exist to support extenders, check out some other resources."
  },
  {
    "objectID": "ggplot2-sublayer-modularity.html",
    "href": "ggplot2-sublayer-modularity.html",
    "title": "ggplot2 sublayer modularity",
    "section": "",
    "text": "If you are a fan of ggplot2, you are probably also a fan of â€˜layerâ€™ functions geom_*() and stat_*().\n\n\n\n\nImportant clarification before we begin: Sometimes all the ggplot2 functions are referred to as ggplot2 â€˜layersâ€™, i.e.Â scales_*(), coord_*(), etc as in â€˜build up your plot layer-by-layerâ€™. *\n\n\n\n\nBut we are using the word in the narrower, sense used in the ggplot2 documentation.\n\n\n\n\nMaybe you get giddy thinking about geom_bump(), geom_ridgeline(), or classic geom_histogram()?\n\n\n\n\nWell-composed geom_*()s and stat_*()s (i.e.Â layer) make for more fluid analytic discovery.\n\n\n\n\nBut what elements constitute a layer function?\n\n\n\n\nLetâ€™s look at geom_bar() to get a feel for what layer composition means.\nIn this plot specification, geom_bar() counts the number of observations that are of each value of x (cut).\n\n\n\n\nThere are actually three main characters in every geom_() or stat_().\n\n\n\n\nThey are geom, stat, and position.\n\n\n\n\nIn geom_bar() the geom is fixed, but stat and position are adjustable. You can see that their defaults are \"count\" and \"stack\" in the functionâ€™s definition.\n\n\n\n\nAnd instead of using convenient geom_bar(), we can use the more generic layer() function - which is actually used under the hood to define all geom_*() and stat_*() functions.\n\n\n\n\nWe can reproduce `geom_bar()`â€˜s behavior with layer(), but we must provide all three â€™control operatorsâ€™:layer(geom = \"bar\", stat = \"count\", position = \"stack\").\n\n\n\n\nOr, equivalently, we can simply name the underlying ggproto objects, GeomBar and StatCount in our case, and the position function, position_stack() .\n\n\n\n\nReiteration: There are actually â€˜control operatorsâ€™ that define the geom_*() and stat_*() user-facing function. Geoms, Stats, and position_*().\n\n\n\n\nYou can refer to them indirectly by quoting their stem, layer(geom = \"bar\", stat = \"count\", position = \"stack\").\n\n\n\n\nOr use the ggproto objects and position function directly, layer(geom = GeomBar, stat = StatCount, position = position_stack())\n\n\n\n\nFocus: Lets look at one â€˜control operatorâ€™, the Stat, more closely.\n\n\n\n\nStats themselves have a number of control elements.\n\n\n\n\nIt transforms plot input data before it is passed off to be rendered.\nStatâ€™s computation is defined in the compute slots.\nAnd in StatCount, compute is done group-wise, so compute_group() defines StatCountâ€™s data transformation.\n\n\n\n\nWe can get a sense of StatCount$compute_groupâ€™s behavior by using on our data.\nFirst, we use select() to make the data look as it would inside of the ggplot2 plotting environment â€” this mirrors the aes(x = cut) mapping declaration.\nThen we see that the data is collapsed by x, and count and prop variables are produced.\n\n\n\n\nWe can think about StatCountâ€™s job as doing some computation that the user might otherwise be responsible for.\n\n\n\n\nWe use StatCount$compute_group() to manually do this computation for us, in conjunction with StatIdentity (leaves data alone) in layer to show this work explicitly.\n\n\n\n\nKey point: We might think Statâ€™s job as lightening the analystâ€™s load - doing computation that the user would otherwise need to do for before plotting.\n\n\n\n\nOne final question you might have is â€™how exactly is the height of the bar, y, communicated to the ggplot2 system? Why does that just work?\n\n\n\n\nThis is managed by the default_aes specification for StatCount.\nBecause there is no variable mapped to y in our plot specification, y position defaults to after_stat(count), in other words the computed variable count that is available after the StatCount computation is done!\n\n\n\n\nAnd it is good to do a little mix-and-match thinking to get a further feel for StatCount. Which of the following plots will have identical outputs?\n\n\n\n\nIs this what you anticipated?\n\n\n\n\nAbove, weâ€™ve had an outside-in look at some aspects of â€˜sublayer modularityâ€™.\nTo get an inside-out look â€” building up your own Stat from scratch â€” you might have a look at â€˜easy geom recipesâ€™ or by joining ggplot2 extenders club\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_bar\n\nfunction (mapping = NULL, data = NULL, stat = \"count\", position = \"stack\", \n    ..., just = 0.5, na.rm = FALSE, orientation = NA, show.legend = NA, \n    inherit.aes = TRUE) \n{\n    layer(data = data, mapping = mapping, stat = stat, geom = GeomBar, \n        position = position, show.legend = show.legend, inherit.aes = inherit.aes, \n        params = list2(just = just, na.rm = na.rm, orientation = orientation, \n            ...))\n}\n&lt;bytecode: 0x7fe7c772e5b8&gt;\n&lt;environment: namespace:ggplot2&gt;\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  layer(geom = \"bar\", stat = \"count\", position = \"stack\")\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, stat = StatCount, position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatCount |&gt; names()\n\n[1] \"default_aes\"   \"extra_params\"  \"super\"         \"compute_group\"\n[5] \"required_aes\"  \"setup_params\"  \"dropped_aes\"  \n\n\n\n\n\nStatCount$compute_group\n\n&lt;ggproto method&gt;\n  &lt;Wrapper function&gt;\n    function (...) \ncompute_group(..., self = self)\n\n  &lt;Inner function (f)&gt;\n    function (self, data, scales, width = NULL, flipped_aes = FALSE) \n{\n    data &lt;- flip_data(data, flipped_aes)\n    x &lt;- data$x\n    weight &lt;- data$weight %||% rep(1, length(x))\n    count &lt;- as.vector(rowsum(weight, x, na.rm = TRUE))\n    bars &lt;- data_frame0(count = count, prop = count/sum(abs(count)), \n        x = sort(unique0(x)), width = width, flipped_aes = flipped_aes, \n        .size = length(count))\n    flip_data(bars, flipped_aes)\n}\n\n\n\n\n\nlibrary(dplyr)\n\ndiamonds |&gt; \n  select(x = cut) |&gt;\n  StatCount$compute_group() \n\n  count       prop         x flipped_aes\n1  1610 0.02984798      Fair       FALSE\n2  4906 0.09095291      Good       FALSE\n3 12082 0.22398962 Very Good       FALSE\n4 13791 0.25567297   Premium       FALSE\n5 21551 0.39953652     Ideal       FALSE\n\n\n\n\n\nprecomputation &lt;- diamonds |&gt; \n  select(x = cut) |&gt;\n  StatCount$compute_group()\n\nprecomputation |&gt;\n  ggplot() + \n  aes(x = x, y = count) + \n  layer(geom = GeomBar, \n        stat = StatIdentity, \n        position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatCount$default_aes\n\nAesthetic mapping: \n* `x`      -&gt; `after_stat(count)`\n* `y`      -&gt; `after_stat(count)`\n* `weight` -&gt; 1\n\nggplot(data = diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, \n        stat = StatCount, \n        position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\np1 &lt;- ggplot(data = diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, \n        stat = StatCount, \n        position = position_stack())\n\np2 &lt;- p1 + geom_point(stat = StatCount)\n\np3 &lt;- p1 + stat_count(geom = GeomPoint)\n\np4 &lt;- p1 + geom_label(stat = StatCount, \n                      aes(label = after_stat(count)))\n\np5 &lt;- p1 + stat_count(geom = GeomText, \n                      aes(label = after_stat(count)), \n                      vjust = 1)\n\n\n\n\nlibrary(patchwork)\np2+ p3 + p4 + p5"
  },
  {
    "objectID": "ggprefixes.html",
    "href": "ggprefixes.html",
    "title": "Who are the ggplot2 extenders?",
    "section": "",
    "text": "user_repo_fun &lt;- read_csv(\"https://raw.githubusercontent.com/EvaMaeRey/mytidytuesday/refs/heads/main/2024-11-19-gg-prefixes/exported_funs_exts_ggplot2_tidyverse_org.csv\") %&gt;% \n  mutate(prefix_short = fun_exported |&gt; str_extract(\".*?_\")) %&gt;% \n  mutate(prefix_long = fun_exported |&gt; str_extract(\"scale_.*?_|.*?_\"))\n\nsample_n(user_repo_fun, 20) |&gt;\n  knitr::kable()\n\n\n\n\n\n\n\n\n\n\n\nuser\nrepo\nfun_exported\nprefix_short\nprefix_long\n\n\n\n\njbengler\ntidyplots\ncolors_continuous_bluepinkyellow\ncolors_\ncolors_\n\n\nLCBC-UiO\nggseg\nreposition_brain\nreposition_\nreposition_\n\n\nmjskay\nggdist\nqlkjcorr_marginal\nqlkjcorr_\nqlkjcorr_\n\n\ntrevorld\nggpattern\nscale_pattern_color_manual\nscale_\nscale_pattern_\n\n\nggobi\nggally\nggally_cor_v1_5\nggally_\nggally_\n\n\ndieghernan\ntidyterra\nglimpse\nNA\nNA\n\n\nlarmarange\nggstats\nggcoef_multinom\nggcoef_\nggcoef_\n\n\nthomasp85\nggforce\ngeom_shape\ngeom_\ngeom_\n\n\naphalo\nggpp\nstat_dens1d_filter\nstat_\nstat_\n\n\nRyo-N7\ntvthemes\ntheme_hildaDay\ntheme_\ntheme_\n\n\nProjectMOSAIC\nggformula\ngf_density_ridges2\ngf_\ngf_\n\n\nteunbrand\nlegendry\nbracket_chevron\nbracket_\nbracket_\n\n\nYunuuuu\nggalign\nfortify_data_frame\nfortify_\nfortify_\n\n\nmalcolmbarrett\nggdag\ngeom_dag\ngeom_\ngeom_\n\n\nroad2stat\nggsci\npal_igv\npal_\npal_\n\n\nclauswilke\nggridges\nGeomVRidgeline\nNA\nNA\n\n\ndieghernan\ntidyterra\nscale_colour_wiki_b\nscale_\nscale_colour_\n\n\nLCBC-UiO\nggseg\nbrain_atlas\nbrain_\nbrain_\n\n\ncorybrunson\nggalluvial\nlode_frontback\nlode_\nlode_\n\n\naphalo\nggspectra\nscale_y_s.q.response_continuous\nscale_\nscale_y_\n\n\n\n\n\n\ndata_filter &lt;- function(.keep, .by) {\n  structure(list(keep_specification = rlang::enquo(.keep), \n                 by_specification = rlang::enquo(.by)), \n            class = \"filterobs\")\n}\n\nggplot_add.filterobs &lt;- function(object, plot, object_name) {\n  \n  new_data &lt;- dplyr::filter(plot$data, \n                            !!object$keep_specification, \n                            .by = !!object$by_specification)\n  plot$data &lt;- new_data\n  plot\n\n}\n\ndata_nest &lt;- function(.by) {\n  structure(list(by_specification = rlang::enquo(.by)),\n            class = \"data_nestvar\")\n  \n}\n\nggplot_add.data_nestvar &lt;- function(object, plot, object_name) {\n\n  \n  new_data &lt;- tidyr::nest(plot$data, \n                          .by = !! object$by_specification)\n    \n  plot$data &lt;- new_data\n  plot\n\n}\n\n\ndata_unnest &lt;- function(cols) {\n  structure(list(),\n            class = \"data_unnestvar\")\n  \n}\n\nggplot_add.data_unnestvar &lt;- function(object, plot, object_name) {\n\n  \n  new_data &lt;- tidyr::unnest(plot$data, cols = \"data\")\n    \n  plot$data &lt;- new_data\n  \n  plot\n\n}\n\n\n\n\n\nthe data frame to be plotted is all the exported functions from the , using ggplot(data = user_repo_fun)\n\n\n\n\nletâ€™s look at a count of all the exported functions first, using aes(id = \"All exported functions\")\n\n\n\n\nUsing circlepacking, we automatically have circles size representing the number of observation, i.e.Â exported functions, using ggcirclepack::geom_circlepack()\n\n\n\n\nOf course this is hard to interpret without some kind of label. We use geom_circplepack_text to do this for us, using ggcirclepack::geom_circlepack_text()\n\n\n\n\nand lets square up the circles, using coord_equal()\n\n\n\n\nweâ€™ll add a theme, using ggchalkboard:::theme_glassboard()\n\n\n\n\nAnd remove axesâ€¦ , using theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())\n\n\n\n\nFirst we ask what packages - github repository names - are present, using aes(id = repo)\n\n\n\n\nThen letâ€™s look at who is writing these exported functions, using aes(id = user)\n\n\n\n\nan extenderâ€™s an extender no matter how small, using data_nest(.by = user)\n\n\n\n\nshrink sizes, using scale_size(range = 1.75)\n\n\n\n\nextender by number of repos, using data_unnest() + data_nest(.by = c(user, repo))\n\n\n\n\nback to default size scales, using scale_size()\n\n\n\n\nback to record per extender (user), using data_unnest()\n\n\n\n\nAnd we can look at what types of functions are exported, by looking at prefixes, using aes(id = prefix_short)\n\n\n\n\nDisaggregating a little, to longer prefixes like scale_color, we get a more granular look at exported function types, using aes(id = prefix_long)\n\n\n\n\nand we filter more popular prefixes, using data_filter(n() &gt; 60 & !is.na(prefix_long), .by = prefix_long)\n\n\n\n\nand break up our plot space by these prefixes, using facet_wrap(~prefix_short)\n\n\n\n\ngf and add_ arenâ€™t really in-grammar prefixes, using data_filter(!(prefix_short %in% c(\"gf_\",\"add_\")))\n\n\n\n\nletâ€™s look at top prefixes by user, using aes(id = user)\n\n\n\n\nand look at the prolific authors in each of these areas, using data_filter(n() &gt;= 10, .by = c(user, prefix_short))\n\n\n\n\nand show them equally, using data_nest(c(user, prefix_short)) + scale_size(range = 1.7)\n\n\n\n\n\n\n\n  ggplot(data = user_repo_fun) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = \"All exported functions\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggcirclepack::geom_circlepack() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggcirclepack::geom_circlepack_text() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    coord_equal() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggchalkboard:::theme_glassboard() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = repo) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = user) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_nest(.by = user) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    scale_size(range = 1.75) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_unnest() + data_nest(.by = c(user, repo)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    scale_size() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_unnest() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = prefix_short) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = prefix_long) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_filter(n() &gt; 60 & !is.na(prefix_long), .by = prefix_long) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    facet_wrap(~prefix_short) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_filter(!(prefix_short %in% c(\"gf_\",\"add_\"))) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = user) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_filter(n() &gt;= 10, .by = c(user, prefix_short)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_nest(c(user, prefix_short)) + scale_size(range = 1.7) \n\n\n\n\n\n\n\n\n\n\n\n\n\nlast_plot()$plot_data\n\nNULL\n\n\nHere is the complete â€˜conversationâ€™ with the dataset!\n\nggplot(data = user_repo_fun) + # the data frame to be plotted is all the exported functions from the \n  aes(id = \"All exported functions\") + # let's look at a count of all the exported functions first\n  ggcirclepack::geom_circlepack() + # Using circlepacking, we automatically have circles size representing the number of observation, i.e. exported functions\n  ggcirclepack::geom_circlepack_text() + # Of course this is hard to interpret without some kind of label.  We use geom_circplepack_text to do this for us\n  coord_equal() + # and lets square up the circles\n  ggchalkboard:::theme_glassboard() + # we'll add a theme\n  theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) + # And remove axes... \n  aes(id = repo) + # First we ask what packages - github repository names - are present\n  aes(id = user) + # Then let's look at who is writing these exported functions\n  data_nest(.by = user) + # an extender's an extender no matter how small\n  scale_size(range = 1.75) + #shrink sizes\n  data_unnest() + data_nest(.by = c(user, repo)) + # extender by number of repos\n  scale_size() + # back to default size scales\n  data_unnest() + # back to record per extender (user)\n  aes(id = prefix_short) + # And we can look at what types of functions are exported, by looking at prefixes\n  aes(id = prefix_long) + # Disaggregating a little, to longer prefixes like scale_color, we get a more granular look at exported function types\n  data_filter(n() &gt; 60 & !is.na(prefix_long), .by = prefix_long) + # and we filter more popular prefixes\n  facet_wrap(~prefix_short) + # and break up our plot space by these prefixes\n  data_filter(!(prefix_short %in% c(\"gf_\",\"add_\"))) + #gf and add_ aren't really in-grammar prefixes\n  aes(id = user) + # let's look at top prefixes by user\n  data_filter(n() &gt;= 10, .by = c(user, prefix_short)) + # and look at the prolific authors in each of these areas\n  data_nest(c(user, prefix_short)) + scale_size(range = 1.7) # and show them equally"
  },
  {
    "objectID": "ggregion.html",
    "href": "ggregion.html",
    "title": "My First Closeread",
    "section": "",
    "text": "ggplot2 allows you build up your plot bit by bit â€“ to write â€˜graphical poemsâ€™ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\nHere is a graphical poem!\n\nggplot(data = cars) + # The first declaration you typically make is the dataframe to plot\n  aes(x = speed, y = dist) + # The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance)\n  geom_point() + # Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples)\n  geom_smooth() # Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) \n\n\n\n\n\n\n\n\nCloseread helps walk people through and digest ideas suggesting a synergy with the gg world. With Closereads, maybe we can read this graphical poem â€˜aloudâ€™, and reflect on it a bit in plain language as we go. Here is a generic way to write out what closereads requires for creating plot output and referring to it.\n\ncr_last_plot_construction &lt;- ':::{focus-on=\"cr-.PLOTXXX\"}\\n.COMMENT, using `.CODE`\\n:::\\n\\n:::{#cr-.PLOTXXX}\\n```{r .PLOTXXX}\\n.LEADING\\n  .CODE\\n```\\n:::\\n'  \n\ncr_last_plot_construction |&gt; cat()\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\nThen we can look at our complete â€˜graphical poemâ€™, parse it, choreograph a line by line reveal - thanks Garrick and Emi for showing the way using powerful knitr::knit_code$get in Xaringan context! https://emitanaka.rbind.io/post/knitr-knitr-code/ At this point we arenâ€™t being really careful with code parsing or replacement; flipbookr internals has some nicer parsing that might be useable and allow more incremental reveals in other contexts like datamanipulation and table creation. In contrast to the full reiterated code that we show in flipbookr w/ Xaringan w/ plot, weâ€™ll use last_plot() + new_code() below. It just feels like a better fit.\n\nknitr::knit_code$get(\"walkthrough\") |&gt;\n  tibble(code_raw = _) |&gt;\n  mutate(comment = str_extract(code_raw, \"#.+$\")) |&gt;\n  mutate(comment = str_remove(comment, \"#\")) |&gt;\n  mutate(code = str_remove(code_raw, \"\\\\+ #.+$|#.+$\")) |&gt;\n  mutate(index = row_number()) |&gt;\n  mutate(plot_name = paste(\"walkthrough\", sep = \"-\", index)) |&gt;\n  mutate(to_cr = cr_last_plot_construction) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".PLOTXXX\", plot_name)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".COMMENT\", comment)) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".CODE\", code)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".LEADING\", ifelse(index == 1, \"\", \"last_plot() +\"))) |&gt;\n  pull(to_cr) -&gt; \nto_closeread\n\nto_closeread\n\n[1] \":::{focus-on=\\\"cr-walkthrough-1\\\"}\\n The first declaration you typically make is the dataframe to plot, using `ggplot(data = cars) `\\n:::\\n\\n:::{#cr-walkthrough-1}\\n```{r walkthrough-1}\\n\\n  ggplot(data = cars) \\n```\\n:::\\n\"                                                                                                           \n[2] \":::{focus-on=\\\"cr-walkthrough-2\\\"}\\n The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using `  aes(x = speed, y = dist) `\\n:::\\n\\n:::{#cr-walkthrough-2}\\n```{r walkthrough-2}\\nlast_plot() +\\n    aes(x = speed, y = dist) \\n```\\n:::\\n\" \n[3] \":::{focus-on=\\\"cr-walkthrough-3\\\"}\\n Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using `  geom_point() `\\n:::\\n\\n:::{#cr-walkthrough-3}\\n```{r walkthrough-3}\\nlast_plot() +\\n    geom_point() \\n```\\n:::\\n\"                             \n[4] \":::{focus-on=\\\"cr-walkthrough-4\\\"}\\n Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using `  geom_smooth() `\\n:::\\n\\n:::{#cr-walkthrough-4}\\n```{r walkthrough-4}\\nlast_plot() +\\n    geom_smooth() \\n```\\n:::\\n\"\n\n\nOkay, ready for the closeread demonstration! (Comparing flipbookr/xaringan implementation what we are doing here, thereâ€™s probably greater focus on narration.) Weâ€™ll use knitr::knit() inline to get this done - paste(knitr::knit(text = to_closeread, quiet = F), collapse = \"\\n\\n\")\n\n\n\n\nThe first declaration you typically make is the dataframe to plot, using ggplot(data = cars)\n\n\n\n\nThe second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using aes(x = speed, y = dist)\n\n\n\n\nThen youâ€™ll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using geom_point()\n\n\n\n\nFinally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using geom_smooth()\n\n\n\n\n\n\n\n  ggplot(data = cars) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(x = speed, y = dist) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_point() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_smooth()"
  },
  {
    "objectID": "positconfspeakers.html",
    "href": "positconfspeakers.html",
    "title": "Who are the ggplot2 extenders?",
    "section": "",
    "text": "conf2023 &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-01-14/conf2023.csv') |&gt; mutate(year = 2023)\nconf2024 &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-01-14/conf2024.csv') |&gt; mutate(year = 2024)\n\nnames(conf2023) \n\n [1] \"speaker_name\"        \"speaker_affiliation\" \"session_type\"       \n [4] \"session_title\"       \"block_track_title\"   \"session_date\"       \n [7] \"session_start\"       \"session_length\"      \"session_abstract\"   \n[10] \"year\"               \n\nnames(conf2024)\n\n[1] \"talk_title\"   \"speaker_name\" \"track\"        \"description\"  \"yt_url\"      \n[6] \"year\"        \n\nsample_n(conf2023, 20)\n\n# A tibble: 20 Ã— 10\n   speaker_name speaker_affiliation session_type session_title block_track_title\n   &lt;chr&gt;        &lt;chr&gt;               &lt;chr&gt;        &lt;chr&gt;         &lt;chr&gt;            \n 1 Albert Rapp  Ulm University      regular      HTML & CSS fâ€¦ Compelling desigâ€¦\n 2 Gordon Shotâ€¦ Posit               regular      Diversify yoâ€¦ Data science witâ€¦\n 3 Kaitlin Busâ€¦ SharpestMinds       lightning    What I Wish â€¦ Lightning talks  \n 4 Vedha Viyash Appsilon            lightning    Shiny Develoâ€¦ Lightning talks  \n 5 Tom Mock     Posit, PBC          regular      Github Copilâ€¦ Data science infâ€¦\n 6 Brian Tarran Royal Statistical â€¦ regular      From journalâ€¦ Quarto (1)       \n 7 Jill MacKay  University of Edinâ€¦ regular      You Can Leadâ€¦ Teaching data scâ€¦\n 8 Liz Roten    Metropolitan Councâ€¦ regular      How to graceâ€¦ Building effectiâ€¦\n 9 Garrick Adeâ€¦ Posit               regular      epoxy: superâ€¦ Elevating your râ€¦\n10 Joe Cheng    Posit Software, PBC regular      Running R-Shâ€¦ I can't believe â€¦\n11 SherAaron Hâ€¦ The Carpentries     regular      R! You Goingâ€¦ Teaching data scâ€¦\n12 Daniel Woodâ€¦ Eli Lilly & Company regular      Developing aâ€¦ Building effectiâ€¦\n13 Reiko Okamoâ€¦ National Research â€¦ regular      What an earlâ€¦ Getting %$!@ donâ€¦\n14 Tomasz Kaliâ€¦ Posit Software, PBC regular      Tracking ML â€¦ Tidy up your modâ€¦\n15 JP Flores    University of Nortâ€¦ lightning    the people oâ€¦ Lightning talks  \n16 Ben Arancibâ€¦ GSK                 regular      The Need forâ€¦ Pharma           \n17 Charlotte Wâ€¦ Posit               regular      What's New iâ€¦ Quarto (1)       \n18 Max Kuhn     posit               regular      Conformal Inâ€¦ Tidy up your modâ€¦\n19 Alexandros â€¦ Appsilon            regular      Hitting the â€¦ Leave it to the â€¦\n20 Sean Nguyen  S2G Ventures        regular      How You Get â€¦ Getting %$!@ donâ€¦\n# â„¹ 5 more variables: session_date &lt;date&gt;, session_start &lt;dttm&gt;,\n#   session_length &lt;dbl&gt;, session_abstract &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\ndata_filter &lt;- function(.keep, .by) {\n  structure(list(keep_specification = rlang::enquo(.keep), \n                 by_specification = rlang::enquo(.by)), \n            class = \"filterobs\")\n}\n\nggplot_add.filterobs &lt;- function(object, plot, object_name) {\n  \n  new_data &lt;- dplyr::filter(plot$data, \n                            !!object$keep_specification, \n                            .by = !!object$by_specification)\n  plot$data &lt;- new_data\n  plot\n\n}\n\ndata_nest &lt;- function(.by) {\n  structure(list(by_specification = rlang::enquo(.by)),\n            class = \"data_nestvar\")\n  \n}\n\nggplot_add.data_nestvar &lt;- function(object, plot, object_name) {\n\n  \n  new_data &lt;- tidyr::nest(plot$data, \n                          .by = !! object$by_specification)\n    \n  plot$data &lt;- new_data\n  plot\n\n}\n\n\ndata_unnest &lt;- function(cols) {\n  structure(list(),\n            class = \"data_unnestvar\")\n  \n}\n\nggplot_add.data_unnestvar &lt;- function(object, plot, object_name) {\n\n  \n  new_data &lt;- tidyr::unnest(plot$data, cols = \"data\")\n    \n  plot$data &lt;- new_data\n  \n  plot\n\n}\n\n\n#' @export\ndata_mutate &lt;- function(.value, .by, var_name) {\n  structure(list(value_specification = rlang::enquo(.value),\n                 by_specification = rlang::enquo(.by),\n                 var_name_specification = var_name),\n            class = \"data_mutate\")\n  \n}\n\nggplot_add.data_mutate &lt;- function(object, plot, object_name) {\n\n  \n  new_data &lt;- dplyr::mutate(plot$data, \n                            .value = !! object$value_specification, \n                            .by = !! object$by_specification)\n  \n    message(\"New variable named '.value' created\")\n    \n\n    if(object$var_name %in% names(new_data)){\n      \n      new_data[,object$var_name] &lt;- new_data$.value\n      \n      new_data &lt;- new_data %&gt;% select(-.value)\n    }else{\n    names(new_data)[names(new_data) == \".value\"] &lt;- object$var_name\n    }\n    \n    \n  plot$data &lt;- new_data\n  plot\n\n}\n\n\n\n\n\nthe data frame to be plotted is all the exported functions from the , using ggplot(data = conf2023)\n\n\n\n\nletâ€™s look at a count of all the exported functions first, using aes(id = \"All Speakers\")\n\n\n\n\nUsing circlepacking we automatically have circles size representing the number of observation, i.e.Â exported functions, using ggcirclepack::geom_circlepack()\n\n\n\n\nWe need to add a label or things are hard to interpret, using ggcirclepack::geom_circlepack_text()\n\n\n\n\nand lets square up the circles, using coord_equal()\n\n\n\n\nweâ€™ll add a theme, using ggchalkboard:::theme_glassboard()\n\n\n\n\nAnd remove axes , using theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())\n\n\n\n\nFirst we ask what packages - github repository names - are present, using aes(id = session_type)\n\n\n\n\nsize range from defaults 1 to 6 and then we can see last category is keynote, using scale_size(range = c(3.5, 8))\n\n\n\n\nThen letâ€™s look at who is writing these exported functions, using aes(id = session_date)\n\n\n\n\nshrink sizes, using scale_size(range = 8)\n\n\n\n\nThen letâ€™s look at who is writing these exported functions, using aes(id = speaker_affiliation) + scale_size()\n\n\n\n\nLetâ€™s just highlight some of the diversity in names, using aes(fill = str_detect(speaker_affiliation, \"Posit\"))\n\n\n\n\nand just delete the fill guide - itâ€™s pretty obvious whatâ€™s being highlighted, using guides(fill = \"none\")\n\n\n\n\nswitch out fill, using scale_fill_manual(values = c(\"lightgrey\", alpha(\"midnightblue\", .2)))\n\n\n\n\nconsolidating, using data_mutate(var_name = \"speaker_affiliation\", ifelse(str_detect(speaker_affiliation, \"Posit\"), \"Posit, PBC\", speaker_affiliation))\n\n\n\n\nLetâ€™s look at repeat speakers just Tom Mock duplicate, using aes(id = speaker_name)\n\n\n\n\nletâ€™s nest the data to one speaker-affiliation, using data_nest(.by = c(speaker_name, speaker_affiliation)) + scale_size(range = 1)\n\n\n\n\nlump affiliations, using aes(id = fct_lump_min(speaker_affiliation, min = 2, other_level = \"Other Affiliation\")) + scale_size(range = c(1.25, 6))\n\n\n\n\nInclude Toms two talks, using data_unnest()\n\n\n\n\nWrapping text, using aes(label = str_wrap(after_stat(id), 12))\n\n\n\n\nNA\n\n\n\n\n\n\n\n  ggplot(data = conf2023) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = \"All Speakers\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggcirclepack::geom_circlepack() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggcirclepack::geom_circlepack_text() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    coord_equal() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggchalkboard:::theme_glassboard() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = session_type) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    scale_size(range = c(3.5, 8)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = session_date) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    scale_size(range = 8) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = speaker_affiliation) + scale_size() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(fill = str_detect(speaker_affiliation, \"Posit\")) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    guides(fill = \"none\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    scale_fill_manual(values = c(\"lightgrey\", alpha(\"midnightblue\", .2))) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_mutate(var_name = \"speaker_affiliation\", ifelse(str_detect(speaker_affiliation, \"Posit\"), \"Posit, PBC\", speaker_affiliation)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = speaker_name) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_nest(.by = c(speaker_name, speaker_affiliation)) + scale_size(range = 1) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = fct_lump_min(speaker_affiliation, min = 2, other_level = \"Other Affiliation\")) + scale_size(range = c(1.25, 6)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_unnest() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(label = str_wrap(after_stat(id), 12)) \n\n\n\n\n\n\n\n\n\n\n\n\n\nlast_plot()$plot_data\n\nNULL\n\n\nHere is the complete â€˜conversationâ€™ with the dataset!\n\nggplot(data = conf2023) + # the data frame to be plotted is all the exported functions from the \n  aes(id = \"All Speakers\") + # let's look at a count of all the exported functions first\n  ggcirclepack::geom_circlepack() + # Using circlepacking we automatically have circles size representing the number of observation, i.e. exported functions\n  ggcirclepack::geom_circlepack_text() + # We need to add a label or things are hard to interpret\n  coord_equal() + # and lets square up the circles\n  ggchalkboard:::theme_glassboard() + # we'll add a theme\n  theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) + # And remove axes \n  aes(id = session_type) + # First we ask what packages - github repository names - are present\n  scale_size(range = c(3.5, 8)) + # size range from defaults 1 to 6 and then we can see last category is keynote\n  aes(id = session_date) + # Then let's look at who is writing these exported functions\n  scale_size(range = 8) + #shrink sizes\n  aes(id = speaker_affiliation) + scale_size() + # Then let's look at who is writing these exported functions\n  aes(fill = str_detect(speaker_affiliation, \"Posit\")) + # Let's just highlight some of the diversity in names\n  guides(fill = \"none\") + # and just delete the fill guide - it's pretty obvious what's being highlighted\n  scale_fill_manual(values = c(\"lightgrey\", alpha(\"midnightblue\", .2))) + # switch out fill\n  data_mutate(var_name = \"speaker_affiliation\", ifelse(str_detect(speaker_affiliation, \"Posit\"), \"Posit, PBC\", speaker_affiliation)) + # consolidating\n  aes(id = speaker_name) + # Let's look at repeat speakers just Tom Mock duplicate\n  data_nest(.by = c(speaker_name, speaker_affiliation)) + scale_size(range = 1) + # let's nest the data to one speaker-affiliation\n  aes(id = fct_lump_min(speaker_affiliation, min = 2, other_level = \"Other Affiliation\")) + scale_size(range = c(1.25, 6)) + # lump affiliations\n  data_unnest() + # Include Toms two talks\n  aes(label = str_wrap(after_stat(id), 12)) + # Wrapping text\n  guides(size = \"none\")"
  }
]