[
  {
    "objectID": "closereads-chunk-reveal.html",
    "href": "closereads-chunk-reveal.html",
    "title": "My First Closeread",
    "section": "",
    "text": "ggplot2 allows you build up your plot bit by bit – to write ‘graphical poems’ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\nHere is a graphical poem!\n\nggplot(data = cars) + # The first declaration you typically make is the dataframe to plot\n  aes(x = speed, y = dist) + # The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance)\n  geom_point() + # Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples)\n  geom_smooth() # Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) \n\n\n\n\n\n\n\n\nCloseread helps walk people through and digest ideas suggesting a synergy with the gg world. With Closereads, maybe we can read this graphical poem ‘aloud’, and reflect on it a bit in plain language as we go. Here is a generic way to write out what closereads requires for creating plot output and referring to it.\n\ncr_last_plot_construction &lt;- ':::{focus-on=\"cr-.PLOTXXX\"}\\n.COMMENT, using `.CODE`\\n:::\\n\\n:::{#cr-.PLOTXXX}\\n```{r .PLOTXXX}\\n.LEADING\\n  .CODE\\n```\\n:::\\n'  \n\ncr_last_plot_construction |&gt; cat()\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\nThen we can look at our complete ‘graphical poem’, parse it, choreograph a line by line reveal - thanks Garrick and Emi for showing the way using powerful knitr::knit_code$get in Xaringan context! https://emitanaka.rbind.io/post/knitr-knitr-code/ At this point we aren’t being really careful with code parsing or replacement; flipbookr internals has some nicer parsing that might be useable and allow more incremental reveals in other contexts like datamanipulation and table creation. In contrast to the full reiterated code that we show in flipbookr w/ Xaringan w/ plot, we’ll use last_plot() + new_code() below. It just feels like a better fit.\n\nknitr::knit_code$get(\"walkthrough\") |&gt;\n  tibble(code_raw = _) |&gt;\n  mutate(comment = str_extract(code_raw, \"#.+$\")) |&gt;\n  mutate(comment = str_remove(comment, \"#\")) |&gt;\n  mutate(code = str_remove(code_raw, \"\\\\+ #.+$|#.+$\")) |&gt;\n  mutate(index = row_number()) |&gt;\n  mutate(plot_name = paste(\"walkthrough\", sep = \"-\", index)) |&gt;\n  mutate(to_cr = cr_last_plot_construction) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".PLOTXXX\", plot_name)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".COMMENT\", comment)) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".CODE\", code)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".LEADING\", ifelse(index == 1, \"\", \"last_plot() +\"))) |&gt;\n  pull(to_cr) -&gt; \nto_closeread\n\nto_closeread\n\n[1] \":::{focus-on=\\\"cr-walkthrough-1\\\"}\\n The first declaration you typically make is the dataframe to plot, using `ggplot(data = cars) `\\n:::\\n\\n:::{#cr-walkthrough-1}\\n```{r walkthrough-1}\\n\\n  ggplot(data = cars) \\n```\\n:::\\n\"                                                                                                           \n[2] \":::{focus-on=\\\"cr-walkthrough-2\\\"}\\n The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using `  aes(x = speed, y = dist) `\\n:::\\n\\n:::{#cr-walkthrough-2}\\n```{r walkthrough-2}\\nlast_plot() +\\n    aes(x = speed, y = dist) \\n```\\n:::\\n\" \n[3] \":::{focus-on=\\\"cr-walkthrough-3\\\"}\\n Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using `  geom_point() `\\n:::\\n\\n:::{#cr-walkthrough-3}\\n```{r walkthrough-3}\\nlast_plot() +\\n    geom_point() \\n```\\n:::\\n\"                             \n[4] \":::{focus-on=\\\"cr-walkthrough-4\\\"}\\n Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using `  geom_smooth() `\\n:::\\n\\n:::{#cr-walkthrough-4}\\n```{r walkthrough-4}\\nlast_plot() +\\n    geom_smooth() \\n```\\n:::\\n\"\n\n\nOkay, ready for the closeread demonstration! (Comparing flipbookr/xaringan implementation what we are doing here, there’s probably greater focus on narration.) We’ll use knitr::knit() inline to get this done - paste(knitr::knit(text = to_closeread, quiet = F), collapse = \"\\n\\n\")\n\n\n\n\nThe first declaration you typically make is the dataframe to plot, using ggplot(data = cars)\n\n\n\n\nThe second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using aes(x = speed, y = dist)\n\n\n\n\nThen you’ll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using geom_point()\n\n\n\n\nFinally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using geom_smooth()\n\n\n\n\n\n\n\n  ggplot(data = cars) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(x = speed, y = dist) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_point() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_smooth()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Everyday ggplot2 closereads 🫖",
    "section": "",
    "text": "Welcome to ggplot2 extenders/ggplot2 extension club. This forum exists to facilitate conversations about experiences with extension. We like to talk about motivations, challenges, equivocations — in general, extension journeys!\nOur main activities are meetings and discussions.\nInterested in joining us? Please leave your contact info here and let us know a little about your interest in ggplot2 extension so we can be in touch!\nNote that the extension ecosystem is extensive and other initiatives exist to support extenders, check out some other resources."
  },
  {
    "objectID": "ggplot2-sublayer-modularity.html",
    "href": "ggplot2-sublayer-modularity.html",
    "title": "ggplot2 sublayer modularity",
    "section": "",
    "text": "If you are a fan of ggplot2, you are probably also a fan of ‘layer’ functions geom_*() and stat_*().\n\n\n\n\nImportant clarification before we begin: Sometimes all the ggplot2 functions are referred to as ggplot2 ‘layers’, i.e. scales_*(), coord_*(), etc as in ‘build up your plot layer-by-layer’. *\n\n\n\n\nBut we are using the word in the narrower, sense used in the ggplot2 documentation.\n\n\n\n\nMaybe you get giddy thinking about geom_bump(), geom_ridgeline(), or classic geom_histogram()?\n\n\n\n\nWell-composed geom_*()s and stat_*()s (i.e. layer) make for more fluid analytic discovery.\n\n\n\n\nBut what elements constitute a layer function?\n\n\n\n\nLet’s look at geom_bar() to get a feel for what layer composition means.\nIn this plot specification, geom_bar() counts the number of observations that are of each value of x (cut).\n\n\n\n\nThere are actually three main characters in every geom_() or stat_().\n\n\n\n\nThey are geom, stat, and position.\n\n\n\n\nIn geom_bar() the geom is fixed, but stat and position are adjustable. You can see that their defaults are \"count\" and \"stack\" in the function’s definition.\n\n\n\n\nAnd instead of using convenient geom_bar(), we can use the more generic layer() function - which is actually used under the hood to define all geom_*() and stat_*() functions.\n\n\n\n\nWe can reproduce `geom_bar()`‘s behavior with layer(), but we must provide all three ’control operators’:layer(geom = \"bar\", stat = \"count\", position = \"stack\").\n\n\n\n\nOr, equivalently, we can simply name the underlying ggproto objects, GeomBar and StatCount in our case, and the position function, position_stack() .\n\n\n\n\nReiteration: There are actually ‘control operators’ that define the geom_*() and stat_*() user-facing function. Geoms, Stats, and position_*().\n\n\n\n\nYou can refer to them indirectly by quoting their stem, layer(geom = \"bar\", stat = \"count\", position = \"stack\").\n\n\n\n\nOr use the ggproto objects and position function directly, layer(geom = GeomBar, stat = StatCount, position = position_stack())\n\n\n\n\nFocus: Lets look at one ‘control operator’, the Stat, more closely.\n\n\n\n\nStats themselves have a number of control elements.\n\n\n\n\nIt transforms plot input data before it is passed off to be rendered.\nStat’s computation is defined in the compute slots.\nAnd in StatCount, compute is done group-wise, so compute_group() defines StatCount’s data transformation.\n\n\n\n\nWe can get a sense of StatCount$compute_group’s behavior by using on our data.\nFirst, we use select() to make the data look as it would inside of the ggplot2 plotting environment — this mirrors the aes(x = cut) mapping declaration.\nThen we see that the data is collapsed by x, and count and prop variables are produced.\n\n\n\n\nWe can think about StatCount’s job as doing some computation that the user might otherwise be responsible for.\n\n\n\n\nWe use StatCount$compute_group() to manually do this computation for us, in conjunction with StatIdentity (leaves data alone) in layer to show this work explicitly.\n\n\n\n\nKey point: We might think Stat’s job as lightening the analyst’s load - doing computation that the user would otherwise need to do for before plotting.\n\n\n\n\nOne final question you might have is ’how exactly is the height of the bar, y, communicated to the ggplot2 system? Why does that just work?\n\n\n\n\nThis is managed by the default_aes specification for StatCount.\nBecause there is no variable mapped to y in our plot specification, y position defaults to after_stat(count), in other words the computed variable count that is available after the StatCount computation is done!\n\n\n\n\nAnd it is good to do a little mix-and-match thinking to get a further feel for StatCount. Which of the following plots will have identical outputs?\n\n\n\n\nIs this what you anticipated?\n\n\n\n\nAbove, we’ve had an outside-in look at some aspects of ‘sublayer modularity’.\nTo get an inside-out look — building up your own Stat from scratch — you might have a look at ‘easy geom recipes’ or by joining ggplot2 extenders club\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_bar\n\nfunction (mapping = NULL, data = NULL, stat = \"count\", position = \"stack\", \n    ..., just = 0.5, na.rm = FALSE, orientation = NA, show.legend = NA, \n    inherit.aes = TRUE) \n{\n    layer(data = data, mapping = mapping, stat = stat, geom = GeomBar, \n        position = position, show.legend = show.legend, inherit.aes = inherit.aes, \n        params = list2(just = just, na.rm = na.rm, orientation = orientation, \n            ...))\n}\n&lt;bytecode: 0x7fe7c772e5b8&gt;\n&lt;environment: namespace:ggplot2&gt;\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  layer(geom = \"bar\", stat = \"count\", position = \"stack\")\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, stat = StatCount, position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatCount |&gt; names()\n\n[1] \"default_aes\"   \"extra_params\"  \"super\"         \"compute_group\"\n[5] \"required_aes\"  \"setup_params\"  \"dropped_aes\"  \n\n\n\n\n\nStatCount$compute_group\n\n&lt;ggproto method&gt;\n  &lt;Wrapper function&gt;\n    function (...) \ncompute_group(..., self = self)\n\n  &lt;Inner function (f)&gt;\n    function (self, data, scales, width = NULL, flipped_aes = FALSE) \n{\n    data &lt;- flip_data(data, flipped_aes)\n    x &lt;- data$x\n    weight &lt;- data$weight %||% rep(1, length(x))\n    count &lt;- as.vector(rowsum(weight, x, na.rm = TRUE))\n    bars &lt;- data_frame0(count = count, prop = count/sum(abs(count)), \n        x = sort(unique0(x)), width = width, flipped_aes = flipped_aes, \n        .size = length(count))\n    flip_data(bars, flipped_aes)\n}\n\n\n\n\n\nlibrary(dplyr)\n\ndiamonds |&gt; \n  select(x = cut) |&gt;\n  StatCount$compute_group() \n\n  count       prop         x flipped_aes\n1  1610 0.02984798      Fair       FALSE\n2  4906 0.09095291      Good       FALSE\n3 12082 0.22398962 Very Good       FALSE\n4 13791 0.25567297   Premium       FALSE\n5 21551 0.39953652     Ideal       FALSE\n\n\n\n\n\nprecomputation &lt;- diamonds |&gt; \n  select(x = cut) |&gt;\n  StatCount$compute_group()\n\nprecomputation |&gt;\n  ggplot() + \n  aes(x = x, y = count) + \n  layer(geom = GeomBar, \n        stat = StatIdentity, \n        position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatCount$default_aes\n\nAesthetic mapping: \n* `x`      -&gt; `after_stat(count)`\n* `y`      -&gt; `after_stat(count)`\n* `weight` -&gt; 1\n\nggplot(data = diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, \n        stat = StatCount, \n        position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\np1 &lt;- ggplot(data = diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, \n        stat = StatCount, \n        position = position_stack())\n\np2 &lt;- p1 + geom_point(stat = StatCount)\n\np3 &lt;- p1 + stat_count(geom = GeomPoint)\n\np4 &lt;- p1 + geom_label(stat = StatCount, \n                      aes(label = after_stat(count)))\n\np5 &lt;- p1 + stat_count(geom = GeomText, \n                      aes(label = after_stat(count)), \n                      vjust = 1)\n\n\n\n\nlibrary(patchwork)\np2+ p3 + p4 + p5"
  },
  {
    "objectID": "ggprefixes.html",
    "href": "ggprefixes.html",
    "title": "Who are the ggplot2 extenders?",
    "section": "",
    "text": "user_repo_fun &lt;- read_csv(\"https://raw.githubusercontent.com/EvaMaeRey/mytidytuesday/refs/heads/main/2024-11-19-gg-prefixes/exported_funs_exts_ggplot2_tidyverse_org.csv\") %&gt;% \n\n  \n  mutate(prefix_short = fun_exported |&gt; str_extract(\".*?_\")) %&gt;% \n  mutate(prefix_long = fun_exported |&gt; str_extract(\"scale_.*?_|.*?_\"))\n\n# user_repo_fun$user |&gt; unique() %&gt;% paste0(\"@\", ., \" \") |&gt; cat()\n\nsample_n(user_repo_fun, 20) |&gt;\n  knitr::kable()\n\n\n\n\n\n\n\n\n\n\n\nuser\nrepo\nfun_exported\nprefix_short\nprefix_long\n\n\n\n\nLCBC-UiO\nggseg\nreposition_brain\nreposition_\nreposition_\n\n\nhrbrmstr\nhrbrthemes\nmodern_geom_defaults\nmodern_\nmodern_\n\n\ndavidgohel\nggiraph\nscale_color_gradient2_interactive\nscale_\nscale_color_\n\n\njtlandis\nggside\nscale_ycolor_manual\nscale_\nscale_ycolor_\n\n\nclauswilke\nggridges\nscale_vline_width_continuous\nscale_\nscale_vline_\n\n\ndavidgohel\nggiraph\ninteractive_raster_grob\ninteractive_\ninteractive_\n\n\nthomasp85\nggfx\nmask_raster\nmask_\nmask_\n\n\npiecepackr\npiecepackr\nhas_font\nhas_\nhas_\n\n\ndieghernan\ntidyterra\nscale_fill_hypso_tint_c\nscale_\nscale_fill_\n\n\nProjectMOSAIC\nggformula\ngf_sina\ngf_\ngf_\n\n\nterrytangyuan\nautoplotly\n“%&gt;%”\nNA\nNA\n\n\nProjectMOSAIC\nggformula\ngf_pointrange\ngf_\ngf_\n\n\ndavidgohel\nggiraph\nopts_hover\nopts_\nopts_\n\n\nshikokuchuo\nichimoku\noanda_studio\noanda_\noanda_\n\n\ndieghernan\ntidyterra\nleft_join\nleft_\nleft_\n\n\nsachsmc\nplotROC\ndirect_label\ndirect_\ndirect_\n\n\nhrbrmstr\nhrbrthemes\nft_text_col\nft_\nft_\n\n\ndavidhodge931\nggblanket\nnavy\nNA\nNA\n\n\nProjectMOSAIC\nggformula\ngf_facet_wrap\ngf_\ngf_\n\n\nthomasp85\nggraph\nscale_edge_fill_fermenter\nscale_\nscale_edge_\n\n\n\n\n\n\ndata_filter &lt;- function(.keep, .by) {\n  structure(list(keep_specification = rlang::enquo(.keep), \n                 by_specification = rlang::enquo(.by)), \n            class = \"filterobs\")\n}\n\nggplot_add.filterobs &lt;- function(object, plot, object_name) {\n  \n  new_data &lt;- dplyr::filter(plot$data, \n                            !!object$keep_specification, \n                            .by = !!object$by_specification)\n  plot$data &lt;- new_data\n  plot\n\n}\n\ndata_nest &lt;- function(.by) {\n  structure(list(by_specification = rlang::enquo(.by)),\n            class = \"data_nestvar\")\n  \n}\n\nggplot_add.data_nestvar &lt;- function(object, plot, object_name) {\n\n  \n  new_data &lt;- tidyr::nest(plot$data, \n                          .by = !! object$by_specification)\n    \n  plot$data &lt;- new_data\n  plot\n\n}\n\n\ndata_unnest &lt;- function(cols) {\n  structure(list(),\n            class = \"data_unnestvar\")\n  \n}\n\nggplot_add.data_unnestvar &lt;- function(object, plot, object_name) {\n\n  \n  new_data &lt;- tidyr::unnest(plot$data, cols = \"data\")\n    \n  plot$data &lt;- new_data\n  \n  plot\n\n}\n\n\n\n\n\nthe data frame to be plotted is all the exported functions from the , using ggplot(data = user_repo_fun)\n\n\n\n\nlet’s look at a count of all the exported functions first, using aes(id = \"All exported functions\")\n\n\n\n\nUsing circlepacking, we automatically have circles size representing the number of observation, i.e. exported functions, using ggcirclepack::geom_circlepack()\n\n\n\n\nOf course this is hard to interpret without some kind of label. We use geom_circplepack_text to do this for us, using ggcirclepack::geom_circlepack_text()\n\n\n\n\nand lets square up the circles, using coord_equal()\n\n\n\n\nwe’ll add a theme, using ggchalkboard:::theme_glassboard()\n\n\n\n\nAnd remove axes… , using theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())\n\n\n\n\nFirst we ask what packages - github repository names - are present, using aes(id = repo)\n\n\n\n\nThen let’s look at who is writing these exported functions, using aes(id = user)\n\n\n\n\nan extender’s an extender no matter how small, using data_nest(.by = user)\n\n\n\n\nshrink sizes, using scale_size(range = 1.75)\n\n\n\n\nextender by number of repos, using data_unnest() + data_nest(.by = c(user, repo))\n\n\n\n\nback to default size scales, using scale_size()\n\n\n\n\nback to record per extender (user), using data_unnest()\n\n\n\n\nAnd we can look at what types of functions are exported, by looking at prefixes, using aes(id = prefix_short)\n\n\n\n\nDisaggregating a little, to longer prefixes like scale_color, we get a more granular look at exported function types, using aes(id = prefix_long)\n\n\n\n\nand we filter more popular prefixes, using data_filter(n() &gt; 60 & !is.na(prefix_long), .by = prefix_long)\n\n\n\n\nand break up our plot space by these prefixes, using facet_wrap(~prefix_short)\n\n\n\n\ngf and add_ aren’t really in-grammar prefixes, using data_filter(!(prefix_short %in% c(\"gf_\",\"add_\")))\n\n\n\n\nlet’s look at top prefixes by user, using aes(id = user)\n\n\n\n\nand look at the prolific authors in each of these areas, using data_filter(n() &gt;= 10, .by = c(user, prefix_short))\n\n\n\n\nand show them equally, using data_nest(c(user, prefix_short)) + scale_size(range = 1.7)\n\n\n\n\n\n\n\n  ggplot(data = user_repo_fun) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = \"All exported functions\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggcirclepack::geom_circlepack() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggcirclepack::geom_circlepack_text() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    coord_equal() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggchalkboard:::theme_glassboard() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = repo) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = user) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_nest(.by = user) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    scale_size(range = 1.75) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_unnest() + data_nest(.by = c(user, repo)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    scale_size() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_unnest() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = prefix_short) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = prefix_long) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_filter(n() &gt; 60 & !is.na(prefix_long), .by = prefix_long) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    facet_wrap(~prefix_short) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_filter(!(prefix_short %in% c(\"gf_\",\"add_\"))) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(id = user) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_filter(n() &gt;= 10, .by = c(user, prefix_short)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    data_nest(c(user, prefix_short)) + scale_size(range = 1.7) \n\n\n\n\n\n\n\n\n\n\n\n\n\nlast_plot()$plot_data\n\nNULL\n\n\nHere is the complete ‘conversation’ with the dataset!\n\nggplot(data = user_repo_fun) + # the data frame to be plotted is all the exported functions from the \n  aes(id = \"All exported functions\") + # let's look at a count of all the exported functions first\n  ggcirclepack::geom_circlepack() + # Using circlepacking, we automatically have circles size representing the number of observation, i.e. exported functions\n  ggcirclepack::geom_circlepack_text() + # Of course this is hard to interpret without some kind of label.  We use geom_circplepack_text to do this for us\n  coord_equal() + # and lets square up the circles\n  ggchalkboard:::theme_glassboard() + # we'll add a theme\n  theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) + # And remove axes... \n  aes(id = repo) + # First we ask what packages - github repository names - are present\n  aes(id = user) + # Then let's look at who is writing these exported functions\n  data_nest(.by = user) + # an extender's an extender no matter how small\n  scale_size(range = 1.75) + #shrink sizes\n  data_unnest() + data_nest(.by = c(user, repo)) + # extender by number of repos\n  scale_size() + # back to default size scales\n  data_unnest() + # back to record per extender (user)\n  aes(id = prefix_short) + # And we can look at what types of functions are exported, by looking at prefixes\n  aes(id = prefix_long) + # Disaggregating a little, to longer prefixes like scale_color, we get a more granular look at exported function types\n  data_filter(n() &gt; 60 & !is.na(prefix_long), .by = prefix_long) + # and we filter more popular prefixes\n  facet_wrap(~prefix_short) + # and break up our plot space by these prefixes\n  data_filter(!(prefix_short %in% c(\"gf_\",\"add_\"))) + #gf and add_ aren't really in-grammar prefixes\n  aes(id = user) + # let's look at top prefixes by user\n  data_filter(n() &gt;= 10, .by = c(user, prefix_short)) + # and look at the prolific authors in each of these areas\n  data_nest(c(user, prefix_short)) + scale_size(range = 1.7) # and show them equally"
  },
  {
    "objectID": "ggregion.html",
    "href": "ggregion.html",
    "title": "My First Closeread",
    "section": "",
    "text": "ggplot2 allows you build up your plot bit by bit – to write ‘graphical poems’ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\nHere is a graphical poem!\n\nggplot(data = cars) + # The first declaration you typically make is the dataframe to plot\n  aes(x = speed, y = dist) + # The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance)\n  geom_point() + # Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples)\n  geom_smooth() # Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) \n\n\n\n\n\n\n\n\nCloseread helps walk people through and digest ideas suggesting a synergy with the gg world. With Closereads, maybe we can read this graphical poem ‘aloud’, and reflect on it a bit in plain language as we go. Here is a generic way to write out what closereads requires for creating plot output and referring to it.\n\ncr_last_plot_construction &lt;- ':::{focus-on=\"cr-.PLOTXXX\"}\\n.COMMENT, using `.CODE`\\n:::\\n\\n:::{#cr-.PLOTXXX}\\n```{r .PLOTXXX}\\n.LEADING\\n  .CODE\\n```\\n:::\\n'  \n\ncr_last_plot_construction |&gt; cat()\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\nThen we can look at our complete ‘graphical poem’, parse it, choreograph a line by line reveal - thanks Garrick and Emi for showing the way using powerful knitr::knit_code$get in Xaringan context! https://emitanaka.rbind.io/post/knitr-knitr-code/ At this point we aren’t being really careful with code parsing or replacement; flipbookr internals has some nicer parsing that might be useable and allow more incremental reveals in other contexts like datamanipulation and table creation. In contrast to the full reiterated code that we show in flipbookr w/ Xaringan w/ plot, we’ll use last_plot() + new_code() below. It just feels like a better fit.\n\nknitr::knit_code$get(\"walkthrough\") |&gt;\n  tibble(code_raw = _) |&gt;\n  mutate(comment = str_extract(code_raw, \"#.+$\")) |&gt;\n  mutate(comment = str_remove(comment, \"#\")) |&gt;\n  mutate(code = str_remove(code_raw, \"\\\\+ #.+$|#.+$\")) |&gt;\n  mutate(index = row_number()) |&gt;\n  mutate(plot_name = paste(\"walkthrough\", sep = \"-\", index)) |&gt;\n  mutate(to_cr = cr_last_plot_construction) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".PLOTXXX\", plot_name)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".COMMENT\", comment)) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".CODE\", code)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".LEADING\", ifelse(index == 1, \"\", \"last_plot() +\"))) |&gt;\n  pull(to_cr) -&gt; \nto_closeread\n\nto_closeread\n\n[1] \":::{focus-on=\\\"cr-walkthrough-1\\\"}\\n The first declaration you typically make is the dataframe to plot, using `ggplot(data = cars) `\\n:::\\n\\n:::{#cr-walkthrough-1}\\n```{r walkthrough-1}\\n\\n  ggplot(data = cars) \\n```\\n:::\\n\"                                                                                                           \n[2] \":::{focus-on=\\\"cr-walkthrough-2\\\"}\\n The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using `  aes(x = speed, y = dist) `\\n:::\\n\\n:::{#cr-walkthrough-2}\\n```{r walkthrough-2}\\nlast_plot() +\\n    aes(x = speed, y = dist) \\n```\\n:::\\n\" \n[3] \":::{focus-on=\\\"cr-walkthrough-3\\\"}\\n Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using `  geom_point() `\\n:::\\n\\n:::{#cr-walkthrough-3}\\n```{r walkthrough-3}\\nlast_plot() +\\n    geom_point() \\n```\\n:::\\n\"                             \n[4] \":::{focus-on=\\\"cr-walkthrough-4\\\"}\\n Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using `  geom_smooth() `\\n:::\\n\\n:::{#cr-walkthrough-4}\\n```{r walkthrough-4}\\nlast_plot() +\\n    geom_smooth() \\n```\\n:::\\n\"\n\n\nOkay, ready for the closeread demonstration! (Comparing flipbookr/xaringan implementation what we are doing here, there’s probably greater focus on narration.) We’ll use knitr::knit() inline to get this done - paste(knitr::knit(text = to_closeread, quiet = F), collapse = \"\\n\\n\")\n\n\n\n\nThe first declaration you typically make is the dataframe to plot, using ggplot(data = cars)\n\n\n\n\nThe second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using aes(x = speed, y = dist)\n\n\n\n\nThen you’ll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using geom_point()\n\n\n\n\nFinally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using geom_smooth()\n\n\n\n\n\n\n\n  ggplot(data = cars) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(x = speed, y = dist) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_point() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_smooth()"
  },
  {
    "objectID": "positconfspeakers.html",
    "href": "positconfspeakers.html",
    "title": "Who are the ggplot2 extenders?",
    "section": "",
    "text": "conf2023 &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-01-14/conf2023.csv') |&gt; mutate(year = 2023)\nconf2024 &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-01-14/conf2024.csv') |&gt; mutate(year = 2024)\n\nnames(conf2023) \n\n [1] \"speaker_name\"        \"speaker_affiliation\" \"session_type\"       \n [4] \"session_title\"       \"block_track_title\"   \"session_date\"       \n [7] \"session_start\"       \"session_length\"      \"session_abstract\"   \n[10] \"year\"               \n\nnames(conf2024)\n\n[1] \"talk_title\"   \"speaker_name\" \"track\"        \"description\"  \"yt_url\"      \n[6] \"year\"        \n\nsample_n(conf2023, 20)\n\n# A tibble: 20 × 10\n   speaker_name speaker_affiliation session_type session_title block_track_title\n   &lt;chr&gt;        &lt;chr&gt;               &lt;chr&gt;        &lt;chr&gt;         &lt;chr&gt;            \n 1 Tiger Tang   CARFAX              regular      From Concept… Bridging the gap…\n 2 Patrick Ten… Meadows Mental Hea… regular      The Gonzalez… Building effecti…\n 3 Camila Saez… Dow, Inc.           lightning    Coding tools… Lightning talks  \n 4 JP Flores    University of Nort… lightning    the people o… Lightning talks  \n 5 Maria Grycuk Appsilon            regular      The Power of… Shiny user inter…\n 6 Joe Roberts  Posit               regular      How I Learne… Managing packages\n 7 Natalia And… Pfizer              regular      Building a C… Pharma           \n 8 Mine Cetink… Posit               regular      Reproducible… Quarto (1)       \n 9 Vedha Viyash Appsilon            lightning    Shiny Develo… Lightning talks  \n10 Jadey Ryan   Washington State D… regular      Custom Quart… Elevating your r…\n11 Erika Tyagi  Urban Institute     regular      Democratizin… End-to-end data …\n12 Gordon Shot… Posit               regular      Diversify yo… Data science wit…\n13 Andrew Patt… Infrastructure Lea… regular      10 solutions… The future is Sh…\n14 Lydia Gibson California State U… regular      How the R fo… Developing your …\n15 Thomas Mich… AXI                 regular      Combining R … R or Python? Why…\n16 Michael Gar… Medable             regular      Integrating … Leave it to the …\n17 Tesla DuBois Fox Chase Cancer C… regular      Solving a Se… Developing your …\n18 James Balam… University of Illi… regular      Dynamic Inte… Quarto (1)       \n19 Elaine McVey Chief               keynote      From Data Co… From Data Confus…\n20 Davis Vaugh… Posit               lightning    dplyr 1.1.0 … Lightning talks  \n# ℹ 5 more variables: session_date &lt;date&gt;, session_start &lt;dttm&gt;,\n#   session_length &lt;dbl&gt;, session_abstract &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\ndata_filter &lt;- function(.keep, .by) {\n  structure(list(keep_specification = rlang::enquo(.keep), \n                 by_specification = rlang::enquo(.by)), \n            class = \"filterobs\")\n}\n\nggplot_add.filterobs &lt;- function(object, plot, object_name) {\n  \n  new_data &lt;- dplyr::filter(plot$data, \n                            !!object$keep_specification, \n                            .by = !!object$by_specification)\n  plot$data &lt;- new_data\n  plot\n\n}\n\ndata_nest &lt;- function(.by) {\n  structure(list(by_specification = rlang::enquo(.by)),\n            class = \"data_nestvar\")\n  \n}\n\nggplot_add.data_nestvar &lt;- function(object, plot, object_name) {\n\n  \n  new_data &lt;- tidyr::nest(plot$data, \n                          .by = !! object$by_specification)\n    \n  plot$data &lt;- new_data\n  plot\n\n}\n\n\ndata_unnest &lt;- function(cols) {\n  structure(list(),\n            class = \"data_unnestvar\")\n  \n}\n\nggplot_add.data_unnestvar &lt;- function(object, plot, object_name) {\n\n  \n  new_data &lt;- tidyr::unnest(plot$data, cols = \"data\")\n    \n  plot$data &lt;- new_data\n  \n  plot\n\n}\n\n\n#' @export\ndata_mutate &lt;- function(.value, .by, var_name) {\n  structure(list(value_specification = rlang::enquo(.value),\n                 by_specification = rlang::enquo(.by),\n                 var_name_specification = var_name),\n            class = \"data_mutate\")\n  \n}\n\nggplot_add.data_mutate &lt;- function(object, plot, object_name) {\n\n  \n  new_data &lt;- dplyr::mutate(plot$data, \n                            .value = !! object$value_specification, \n                            .by = !! object$by_specification)\n  \n    message(\"New variable named '.value' created\")\n    \n\n    if(object$var_name %in% names(new_data)){\n      \n      new_data[,object$var_name] &lt;- new_data$.value\n      \n      new_data &lt;- new_data %&gt;% select(-.value)\n    }else{\n    names(new_data)[names(new_data) == \".value\"] &lt;- object$var_name\n    }\n    \n    \n  plot$data &lt;- new_data\n  plot\n\n}\n\n\n\n\n\n\n\n\nr paste(knitr::knit(text = to_closeread, quiet = F), collapse = “”)`\n\n\n\n\n\n\n\n\n\n\nlast_plot()$plot_data\n\nNULL\n\n\nHere is the complete ‘conversation’ with the dataset!\n\nggplot(data = conf2023) + # the data frame to be plotted is all the exported functions from the \n  aes(id = \"All Speakers\") + # let's look at a count of all the exported functions first\n  ggcirclepack::geom_circlepack() + # Using circlepacking we automatically have circles size representing the number of observation, i.e. exported functions\n  ggcirclepack::geom_circlepack_text() + # We need to add a label or things are hard to interpret\n  coord_equal() + # and lets square up the circles\n  ggchalkboard:::theme_glassboard() + # we'll add a theme\n  theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) + # And remove axes \n  aes(id = session_type) + # First we ask what packages - github repository names - are present\n  scale_size(range = c(3.5, 8)) + # size range from defaults 1 to 6 and then we can see last category is keynote\n  aes(id = session_date) + scale_size(range = 8) + # Then let's look at who is writing these exported functions\n  aes(id = speaker_affiliation) + scale_size() + # Then let's look at who is writing these exported functions\n  aes(fill = str_detect(speaker_affiliation, \"Posit\")) + guides(fill = \"none\") + # Let's just highlight some of the diversity in names\n # and just delete the fill guide - it's pretty obvious what's being highlighted\n  scale_fill_manual(values = c(\"lightgrey\", alpha(\"midnightblue\", .2))) + # switch out fill\n  data_mutate(var_name = \"speaker_affiliation\", ifelse(str_detect(speaker_affiliation, \"Posit\"), \"Posit, PBC\", speaker_affiliation)) + # consolidating\n  aes(id = speaker_name) + # Let's look at repeat speakers just Tom Mock duplicate\n  data_nest(.by = c(speaker_name, speaker_affiliation)) + scale_size(range = 1) + # let's nest the data to one speaker-affiliation\n  aes(id = fct_lump_min(speaker_affiliation, min = 2, other_level = \"Other Affiliation\")) + scale_size(range = c(1.25, 6)) + # lump affiliations\n  data_unnest() + # Include Toms two talks\n  aes(label = str_wrap(after_stat(id), 12)) + # Wrapping text\n  guides(size = \"none\")"
  },
  {
    "objectID": "ggaluvial.html",
    "href": "ggaluvial.html",
    "title": "My First Closeread",
    "section": "",
    "text": "ggplot2 allows you build up your plot bit by bit – to write ‘graphical poems’ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\n\nlibrary(ggalluvial)\nlibrary(ggplot2)\ntitanic_wide &lt;- data.frame(Titanic)\nhead(titanic_wide)\n\n  Class    Sex   Age Survived Freq\n1   1st   Male Child       No    0\n2   2nd   Male Child       No    0\n3   3rd   Male Child       No   35\n4  Crew   Male Child       No    0\n5   1st Female Child       No    0\n6   2nd Female Child       No    0\n\n#&gt;   Class    Sex   Age Survived Freq\n#&gt; 1   1st   Male Child       No    0\n#&gt; 2   2nd   Male Child       No    0\n#&gt; 3   3rd   Male Child       No   35\n#&gt; 4  Crew   Male Child       No    0\n#&gt; 5   1st Female Child       No    0\n#&gt; 6   2nd Female Child       No    0\n#&gt; \n\nStatStratum$default_aes &lt;- aes(label = after_stat(stratum))\ngeom_stratum_text &lt;- function(...){geom_text(stat = \"stratum\", ...)}\n\n\nGeomStratum$default_aes\n\nAesthetic mapping: \n* `size`      -&gt; 0.5\n* `linewidth` -&gt; 0.5\n* `linetype`  -&gt; 1\n* `colour`    -&gt; \"black\"\n* `fill`      -&gt; \"white\"\n* `alpha`     -&gt; 1\n\n\nHere is a graphical poem!\n\nggplot(data = titanic_wide) + # Ok Let's look at this titanic data\n  aes(axis1 = Class, axis2 = Sex, axis3 = Age, y = Freq) + # Here some variables of interest what if y were weight\n  scale_x_discrete(limits = c(\"Class\", \"Sex\", \"Age\"), expand = c(.2, .05)) + # adjusting the x axis\n  ggchalkboard::theme_chalkboard(base_size = 12) + # We ll use a teaching theme Alluvial plots might be new to you\n  geom_alluvium() + # And we are ready to look at flow\n  geom_stratum(fill = \"darkseagreen4\", color = alpha(\"lightyellow\",.5)) + # And we can label our stratumaxes\n  geom_stratum_text() + # Add stratum labels\n  aes(fill = Survived) + # look at flow w survival color\n  labs(x = \"Demographic\") + # An overall label for x axis\n  labs(title = \"Passengers on the maiden voyage of the Titanic\") + # hello \n  labs(subtitle = \"stratified by demographics and survival\") # hello\n\n\n\n\n\n\n\n\nCloseread helps walk people through and digest ideas suggesting a synergy with the gg world. With Closereads, maybe we can read this graphical poem ‘aloud’, and reflect on it a bit in plain language as we go. Here is a generic way to write out what closereads requires for creating plot output and referring to it.\n\ncr_last_plot_construction &lt;- ':::{focus-on=\"cr-.PLOTXXX\"}\\n.COMMENT, using `.CODE`\\n:::\\n\\n:::{#cr-.PLOTXXX}\\n```{r .PLOTXXX}\\n.LEADING\\n  .CODE\\n```\\n:::\\n'  \n\ncr_last_plot_construction |&gt; cat()\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\nThen we can look at our complete ‘graphical poem’, parse it, choreograph a line by line reveal - thanks Garrick and Emi for showing the way using powerful knitr::knit_code$get in Xaringan context! https://emitanaka.rbind.io/post/knitr-knitr-code/ At this point we aren’t being really careful with code parsing or replacement; flipbookr internals has some nicer parsing that might be useable and allow more incremental reveals in other contexts like datamanipulation and table creation. In contrast to the full reiterated code that we show in flipbookr w/ Xaringan w/ plot, we’ll use last_plot() + new_code() below. It just feels like a better fit.\n\nknitr::knit_code$get(\"walkthrough\") |&gt;\n  tibble(code_raw = _) |&gt;\n  mutate(comment = str_extract(code_raw, \"#.+$\")) |&gt;\n  mutate(comment = str_remove(comment, \"#\")) |&gt;\n  mutate(code = str_remove(code_raw, \"\\\\+ #.+$|#.+$\")) |&gt;\n  mutate(index = row_number()) |&gt;\n  mutate(plot_name = paste(\"walkthrough\", sep = \"-\", index)) |&gt;\n  mutate(to_cr = cr_last_plot_construction) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".PLOTXXX\", plot_name)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".COMMENT\", comment)) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".CODE\", code)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".LEADING\", ifelse(index == 1, \"\", \"last_plot() +\"))) |&gt;\n  pull(to_cr) -&gt; \nto_closeread\n\nto_closeread\n\n [1] \":::{focus-on=\\\"cr-walkthrough-1\\\"}\\n Ok Let's look at this titanic data, using `ggplot(data = titanic_wide) `\\n:::\\n\\n:::{#cr-walkthrough-1}\\n```{r walkthrough-1}\\n\\n  ggplot(data = titanic_wide) \\n```\\n:::\\n\"                                                                                                           \n [2] \":::{focus-on=\\\"cr-walkthrough-2\\\"}\\n Here some variables of interest what if y were weight, using `  aes(axis1 = Class, axis2 = Sex, axis3 = Age, y = Freq) `\\n:::\\n\\n:::{#cr-walkthrough-2}\\n```{r walkthrough-2}\\nlast_plot() +\\n    aes(axis1 = Class, axis2 = Sex, axis3 = Age, y = Freq) \\n```\\n:::\\n\"                 \n [3] \":::{focus-on=\\\"cr-walkthrough-3\\\"}\\n adjusting the x axis, using `  scale_x_discrete(limits = c(\\\"Class\\\", \\\"Sex\\\", \\\"Age\\\"), expand = c(.2, .05)) `\\n:::\\n\\n:::{#cr-walkthrough-3}\\n```{r walkthrough-3}\\nlast_plot() +\\n    scale_x_discrete(limits = c(\\\"Class\\\", \\\"Sex\\\", \\\"Age\\\"), expand = c(.2, .05)) \\n```\\n:::\\n\"  \n [4] \":::{focus-on=\\\"cr-walkthrough-4\\\"}\\n We ll use a teaching theme Alluvial plots might be new to you, using `  ggchalkboard::theme_chalkboard(base_size = 12) `\\n:::\\n\\n:::{#cr-walkthrough-4}\\n```{r walkthrough-4}\\nlast_plot() +\\n    ggchalkboard::theme_chalkboard(base_size = 12) \\n```\\n:::\\n\"                         \n [5] \":::{focus-on=\\\"cr-walkthrough-5\\\"}\\n And we are ready to look at flow, using `  geom_alluvium() `\\n:::\\n\\n:::{#cr-walkthrough-5}\\n```{r walkthrough-5}\\nlast_plot() +\\n    geom_alluvium() \\n```\\n:::\\n\"                                                                                                                    \n [6] \":::{focus-on=\\\"cr-walkthrough-6\\\"}\\n And we can label our stratumaxes, using `  geom_stratum(fill = \\\"darkseagreen4\\\", color = alpha(\\\"lightyellow\\\",.5)) `\\n:::\\n\\n:::{#cr-walkthrough-6}\\n```{r walkthrough-6}\\nlast_plot() +\\n    geom_stratum(fill = \\\"darkseagreen4\\\", color = alpha(\\\"lightyellow\\\",.5)) \\n```\\n:::\\n\"\n [7] \":::{focus-on=\\\"cr-walkthrough-7\\\"}\\n Add stratum labels, using `  geom_stratum_text() `\\n:::\\n\\n:::{#cr-walkthrough-7}\\n```{r walkthrough-7}\\nlast_plot() +\\n    geom_stratum_text() \\n```\\n:::\\n\"                                                                                                                          \n [8] \":::{focus-on=\\\"cr-walkthrough-8\\\"}\\n look at flow w survival color, using `  aes(fill = Survived) `\\n:::\\n\\n:::{#cr-walkthrough-8}\\n```{r walkthrough-8}\\nlast_plot() +\\n    aes(fill = Survived) \\n```\\n:::\\n\"                                                                                                             \n [9] \":::{focus-on=\\\"cr-walkthrough-9\\\"}\\n An overall label for x axis, using `  labs(x = \\\"Demographic\\\") `\\n:::\\n\\n:::{#cr-walkthrough-9}\\n```{r walkthrough-9}\\nlast_plot() +\\n    labs(x = \\\"Demographic\\\") \\n```\\n:::\\n\"                                                                                                     \n[10] \":::{focus-on=\\\"cr-walkthrough-10\\\"}\\n hello , using `  labs(title = \\\"Passengers on the maiden voyage of the Titanic\\\") `\\n:::\\n\\n:::{#cr-walkthrough-10}\\n```{r walkthrough-10}\\nlast_plot() +\\n    labs(title = \\\"Passengers on the maiden voyage of the Titanic\\\") \\n```\\n:::\\n\"                                         \n[11] \":::{focus-on=\\\"cr-walkthrough-11\\\"}\\n hello, using `  labs(subtitle = \\\"stratified by demographics and survival\\\") `\\n:::\\n\\n:::{#cr-walkthrough-11}\\n```{r walkthrough-11}\\nlast_plot() +\\n    labs(subtitle = \\\"stratified by demographics and survival\\\") \\n```\\n:::\\n\"                                                  \n\n\nOkay, ready for the closeread demonstration! (Comparing flipbookr/xaringan implementation what we are doing here, there’s probably greater focus on narration.) We’ll use knitr::knit() inline to get this done - paste(knitr::knit(text = to_closeread, quiet = F), collapse = \"\\n\\n\")\n\n\n\n\nOk Let’s look at this titanic data, using ggplot(data = titanic_wide)\n\n\n\n\nHere some variables of interest what if y were weight, using aes(axis1 = Class, axis2 = Sex, axis3 = Age, y = Freq)\n\n\n\n\nadjusting the x axis, using scale_x_discrete(limits = c(\"Class\", \"Sex\", \"Age\"), expand = c(.2, .05))\n\n\n\n\nWe ll use a teaching theme Alluvial plots might be new to you, using ggchalkboard::theme_chalkboard(base_size = 12)\n\n\n\n\nAnd we are ready to look at flow, using geom_alluvium()\n\n\n\n\nAnd we can label our stratumaxes, using geom_stratum(fill = \"darkseagreen4\", color = alpha(\"lightyellow\",.5))\n\n\n\n\nAdd stratum labels, using geom_stratum_text()\n\n\n\n\nlook at flow w survival color, using aes(fill = Survived)\n\n\n\n\nAn overall label for x axis, using labs(x = \"Demographic\")\n\n\n\n\nhello , using labs(title = \"Passengers on the maiden voyage of the Titanic\")\n\n\n\n\nhello, using labs(subtitle = \"stratified by demographics and survival\")\n\n\n\n\n\n\n\n  ggplot(data = titanic_wide) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(axis1 = Class, axis2 = Sex, axis3 = Age, y = Freq) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    scale_x_discrete(limits = c(\"Class\", \"Sex\", \"Age\"), expand = c(.2, .05)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggchalkboard::theme_chalkboard(base_size = 12) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_alluvium() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_stratum(fill = \"darkseagreen4\", color = alpha(\"lightyellow\",.5)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_stratum_text() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(fill = Survived) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    labs(x = \"Demographic\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    labs(title = \"Passengers on the maiden voyage of the Titanic\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    labs(subtitle = \"stratified by demographics and survival\")"
  },
  {
    "objectID": "ggalluvial.html",
    "href": "ggalluvial.html",
    "title": "ggalluvial",
    "section": "",
    "text": "ggplot2 allows you build up your plot bit by bit – to write ‘graphical poems’ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\n\nlibrary(ggalluvial)\nlibrary(ggplot2)\ntitanic_wide &lt;- data.frame(Titanic)\nhead(titanic_wide)\n\n  Class    Sex   Age Survived Freq\n1   1st   Male Child       No    0\n2   2nd   Male Child       No    0\n3   3rd   Male Child       No   35\n4  Crew   Male Child       No    0\n5   1st Female Child       No    0\n6   2nd Female Child       No    0\n\n#&gt;   Class    Sex   Age Survived Freq\n#&gt; 1   1st   Male Child       No    0\n#&gt; 2   2nd   Male Child       No    0\n#&gt; 3   3rd   Male Child       No   35\n#&gt; 4  Crew   Male Child       No    0\n#&gt; 5   1st Female Child       No    0\n#&gt; 6   2nd Female Child       No    0\n#&gt; \n\nStatStratum$default_aes &lt;- aes(label = after_stat(stratum))\ngeom_stratum_text &lt;- function(...){geom_text(stat = StatStratum, ...)}\n\nlibrary(ggplot2)\nlibrary(ggalluvial)\n\nGeomStratum$default_aes # hardcoded\n\nAesthetic mapping: \n* `size`      -&gt; 0.5\n* `linewidth` -&gt; 0.5\n* `linetype`  -&gt; 1\n* `colour`    -&gt; \"black\"\n* `fill`      -&gt; \"white\"\n* `alpha`     -&gt; 1\n\nGeomRect$default_aes\n\nAesthetic mapping: \n* `colour`    -&gt; NA\n* `fill`      -&gt; `from_theme(col_mix(ink, paper, 0.35))`\n* `linewidth` -&gt; `from_theme(borderwidth)`\n* `linetype`  -&gt; `from_theme(bordertype)`\n* `alpha`     -&gt; NA\n\nGeomStratum$default_aes &lt;- GeomRect$default_aes\nGeomStratum$default_aes &lt;- modifyList(GeomRect$default_aes, \n                                      aes(color = from_theme(ggplot2:::col_mix(ink, paper, 0.15))))\n\nHere is a graphical poem!\n\nggplot(data = titanic_wide) + # Ok Lets look at this titanic data\n  aes(y = Freq, axis1 = Sex, axis2 = Survived) + # Here some variables of interest\n  ggchalkboard:::theme_slateboard(base_size = 18) + # in a alluvial plot first look\n  geom_alluvium() + # And we are ready to look at flow\n  geom_stratum(aes(fill = NULL)) + # And we can label our stratum axes\n  geom_stratum_text() + # Add stratum labels\n  aes(axis1 = Age) + # look at age to survival\n  aes(axis1 = Class) + # look at class to survival\n  aes(axis1 = Age, axis2 = Class, axis3 = Survived) + # age to class to survival\n  aes(axis1 = Sex, axis2 = Age, axis3 = Class, axis4 = Survived) + # a train\n  aes(fill = Sex) + # Track sex throughout\n  guides(fill = \"none\") + # remove fill guide as axis1 is labeled\n  scale_x_discrete(limits = c(\"Sex\", \"Age\", \"Class\", \"Survived\"), expand = c(.1, .1)) + # adjusting the x axis\n  labs(x = \"Demographic\") + # An overall label for x axis\n  labs(caption = \"Passengers on the maiden voyage of the Titanic\") + # adding a caption \n  aes(axis1 = fct_rev(Sex)) + # minimize flow crossing\n  aes(axis4 = fct_rev(Survived)) + # minimize flow crossing\n  aes(axis2 = NULL) + # remove Age\n  aes(axis1 = ifelse(Sex == \"Female\" | Age == \"Child\", \"Female or Child\", \"Male Adult\")) + # Replace axis 1\n    scale_x_discrete(limits = c(\"Sex & Age\", \"Class\", \"Survived\"), expand = c(.2, .1)) + # adjusting the x axis\n  aes(fill = ifelse(Sex == \"Female\" | Age == \"Child\", \"Female or Child\", \"Male Adult\")) # More \n\n\n\n\n\n\n\n\nCloseread helps walk people through and digest ideas suggesting a synergy with the gg world. With Closereads, maybe we can read this graphical poem ‘aloud’, and reflect on it a bit in plain language as we go. Here is a generic way to write out what closereads requires for creating plot output and referring to it.\n\ncr_last_plot_construction &lt;- ':::{focus-on=\"cr-.PLOTXXX\"}\\n.COMMENT, using `.CODE`\\n:::\\n\\n:::{#cr-.PLOTXXX}\\n```{r .PLOTXXX}\\n.LEADING\\n  .CODE\\n```\\n:::\\n'  \n\ncr_last_plot_construction |&gt; cat()\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\nThen we can look at our complete ‘graphical poem’, parse it, choreograph a line by line reveal - thanks Garrick and Emi for showing the way using powerful knitr::knit_code$get in Xaringan context! https://emitanaka.rbind.io/post/knitr-knitr-code/ At this point we aren’t being really careful with code parsing or replacement; flipbookr internals has some nicer parsing that might be useable and allow more incremental reveals in other contexts like datamanipulation and table creation. In contrast to the full reiterated code that we show in flipbookr w/ Xaringan w/ plot, we’ll use last_plot() + new_code() below. It just feels like a better fit.\n\nknitr::knit_code$get(\"walkthrough\") |&gt;\n  tibble(code_raw = _) |&gt;\n  mutate(comment = str_extract(code_raw, \"#.+$\")) |&gt;\n  mutate(comment = str_remove(comment, \"#\")) |&gt;\n  mutate(code = str_remove(code_raw, \"\\\\+ #.+$|#.+$\")) |&gt;\n  mutate(index = row_number()) |&gt;\n  mutate(plot_name = paste(\"walkthrough\", sep = \"-\", index)) |&gt;\n  mutate(to_cr = cr_last_plot_construction) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".PLOTXXX\", plot_name)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".COMMENT\", comment)) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".CODE\", code)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".LEADING\", ifelse(index == 1, \"\", \"last_plot() +\"))) |&gt;\n  pull(to_cr) -&gt; \nto_closeread\n\nto_closeread\n\n [1] \":::{focus-on=\\\"cr-walkthrough-1\\\"}\\n Ok Lets look at this titanic data, using `ggplot(data = titanic_wide) `\\n:::\\n\\n:::{#cr-walkthrough-1}\\n```{r walkthrough-1}\\n\\n  ggplot(data = titanic_wide) \\n```\\n:::\\n\"                                                                                                                                       \n [2] \":::{focus-on=\\\"cr-walkthrough-2\\\"}\\n Here some variables of interest, using `  aes(y = Freq, axis1 = Sex, axis2 = Survived) `\\n:::\\n\\n:::{#cr-walkthrough-2}\\n```{r walkthrough-2}\\nlast_plot() +\\n    aes(y = Freq, axis1 = Sex, axis2 = Survived) \\n```\\n:::\\n\"                                                                                      \n [3] \":::{focus-on=\\\"cr-walkthrough-3\\\"}\\n in a alluvial plot first look, using `  ggchalkboard:::theme_slateboard(base_size = 18) `\\n:::\\n\\n:::{#cr-walkthrough-3}\\n```{r walkthrough-3}\\nlast_plot() +\\n    ggchalkboard:::theme_slateboard(base_size = 18) \\n```\\n:::\\n\"                                                                                  \n [4] \":::{focus-on=\\\"cr-walkthrough-4\\\"}\\n And we are ready to look at flow, using `  geom_alluvium() `\\n:::\\n\\n:::{#cr-walkthrough-4}\\n```{r walkthrough-4}\\nlast_plot() +\\n    geom_alluvium() \\n```\\n:::\\n\"                                                                                                                                               \n [5] \":::{focus-on=\\\"cr-walkthrough-5\\\"}\\n And we can label our stratum axes, using `  geom_stratum(aes(fill = NULL)) `\\n:::\\n\\n:::{#cr-walkthrough-5}\\n```{r walkthrough-5}\\nlast_plot() +\\n    geom_stratum(aes(fill = NULL)) \\n```\\n:::\\n\"                                                                                                                \n [6] \":::{focus-on=\\\"cr-walkthrough-6\\\"}\\n Add stratum labels, using `  geom_stratum_text() `\\n:::\\n\\n:::{#cr-walkthrough-6}\\n```{r walkthrough-6}\\nlast_plot() +\\n    geom_stratum_text() \\n```\\n:::\\n\"                                                                                                                                                     \n [7] \":::{focus-on=\\\"cr-walkthrough-7\\\"}\\n look at age to survival, using `  aes(axis1 = Age) `\\n:::\\n\\n:::{#cr-walkthrough-7}\\n```{r walkthrough-7}\\nlast_plot() +\\n    aes(axis1 = Age) \\n```\\n:::\\n\"                                                                                                                                                      \n [8] \":::{focus-on=\\\"cr-walkthrough-8\\\"}\\n look at class to survival, using `  aes(axis1 = Class) `\\n:::\\n\\n:::{#cr-walkthrough-8}\\n```{r walkthrough-8}\\nlast_plot() +\\n    aes(axis1 = Class) \\n```\\n:::\\n\"                                                                                                                                                \n [9] \":::{focus-on=\\\"cr-walkthrough-9\\\"}\\n age to class to survival, using `  aes(axis1 = Age, axis2 = Class, axis3 = Survived) `\\n:::\\n\\n:::{#cr-walkthrough-9}\\n```{r walkthrough-9}\\nlast_plot() +\\n    aes(axis1 = Age, axis2 = Class, axis3 = Survived) \\n```\\n:::\\n\"                                                                                   \n[10] \":::{focus-on=\\\"cr-walkthrough-10\\\"}\\n a train, using `  aes(axis1 = Sex, axis2 = Age, axis3 = Class, axis4 = Survived) `\\n:::\\n\\n:::{#cr-walkthrough-10}\\n```{r walkthrough-10}\\nlast_plot() +\\n    aes(axis1 = Sex, axis2 = Age, axis3 = Class, axis4 = Survived) \\n```\\n:::\\n\"                                                                       \n[11] \":::{focus-on=\\\"cr-walkthrough-11\\\"}\\n Track sex throughout, using `  aes(fill = Sex) `\\n:::\\n\\n:::{#cr-walkthrough-11}\\n```{r walkthrough-11}\\nlast_plot() +\\n    aes(fill = Sex) \\n```\\n:::\\n\"                                                                                                                                                        \n[12] \":::{focus-on=\\\"cr-walkthrough-12\\\"}\\n remove fill guide as axis1 is labeled, using `  guides(fill = \\\"none\\\") `\\n:::\\n\\n:::{#cr-walkthrough-12}\\n```{r walkthrough-12}\\nlast_plot() +\\n    guides(fill = \\\"none\\\") \\n```\\n:::\\n\"                                                                                                                       \n[13] \":::{focus-on=\\\"cr-walkthrough-13\\\"}\\n adjusting the x axis, using `  scale_x_discrete(limits = c(\\\"Sex\\\", \\\"Age\\\", \\\"Class\\\", \\\"Survived\\\"), expand = c(.1, .1)) `\\n:::\\n\\n:::{#cr-walkthrough-13}\\n```{r walkthrough-13}\\nlast_plot() +\\n    scale_x_discrete(limits = c(\\\"Sex\\\", \\\"Age\\\", \\\"Class\\\", \\\"Survived\\\"), expand = c(.1, .1)) \\n```\\n:::\\n\"\n[14] \":::{focus-on=\\\"cr-walkthrough-14\\\"}\\n An overall label for x axis, using `  labs(x = \\\"Demographic\\\") `\\n:::\\n\\n:::{#cr-walkthrough-14}\\n```{r walkthrough-14}\\nlast_plot() +\\n    labs(x = \\\"Demographic\\\") \\n```\\n:::\\n\"                                                                                                                             \n[15] \":::{focus-on=\\\"cr-walkthrough-15\\\"}\\n adding a caption , using `  labs(caption = \\\"Passengers on the maiden voyage of the Titanic\\\") `\\n:::\\n\\n:::{#cr-walkthrough-15}\\n```{r walkthrough-15}\\nlast_plot() +\\n    labs(caption = \\\"Passengers on the maiden voyage of the Titanic\\\") \\n```\\n:::\\n\"                                                     \n[16] \":::{focus-on=\\\"cr-walkthrough-16\\\"}\\n minimize flow crossing, using `  aes(axis1 = fct_rev(Sex)) `\\n:::\\n\\n:::{#cr-walkthrough-16}\\n```{r walkthrough-16}\\nlast_plot() +\\n    aes(axis1 = fct_rev(Sex)) \\n```\\n:::\\n\"                                                                                                                                  \n[17] \":::{focus-on=\\\"cr-walkthrough-17\\\"}\\n minimize flow crossing, using `  aes(axis4 = fct_rev(Survived)) `\\n:::\\n\\n:::{#cr-walkthrough-17}\\n```{r walkthrough-17}\\nlast_plot() +\\n    aes(axis4 = fct_rev(Survived)) \\n```\\n:::\\n\"                                                                                                                        \n[18] \":::{focus-on=\\\"cr-walkthrough-18\\\"}\\n remove Age, using `  aes(axis2 = NULL) `\\n:::\\n\\n:::{#cr-walkthrough-18}\\n```{r walkthrough-18}\\nlast_plot() +\\n    aes(axis2 = NULL) \\n```\\n:::\\n\"                                                                                                                                                              \n[19] \":::{focus-on=\\\"cr-walkthrough-19\\\"}\\n Replace axis 1, using `  aes(axis1 = ifelse(Sex == \\\"Female\\\" | Age == \\\"Child\\\", \\\"Female or Child\\\", \\\"Male Adult\\\")) `\\n:::\\n\\n:::{#cr-walkthrough-19}\\n```{r walkthrough-19}\\nlast_plot() +\\n    aes(axis1 = ifelse(Sex == \\\"Female\\\" | Age == \\\"Child\\\", \\\"Female or Child\\\", \\\"Male Adult\\\")) \\n```\\n:::\\n\"\n[20] \":::{focus-on=\\\"cr-walkthrough-20\\\"}\\n adjusting the x axis, using `    scale_x_discrete(limits = c(\\\"Sex & Age\\\", \\\"Class\\\", \\\"Survived\\\"), expand = c(.2, .1)) `\\n:::\\n\\n:::{#cr-walkthrough-20}\\n```{r walkthrough-20}\\nlast_plot() +\\n      scale_x_discrete(limits = c(\\\"Sex & Age\\\", \\\"Class\\\", \\\"Survived\\\"), expand = c(.2, .1)) \\n```\\n:::\\n\"  \n[21] \":::{focus-on=\\\"cr-walkthrough-21\\\"}\\n More , using `  aes(fill = ifelse(Sex == \\\"Female\\\" | Age == \\\"Child\\\", \\\"Female or Child\\\", \\\"Male Adult\\\")) `\\n:::\\n\\n:::{#cr-walkthrough-21}\\n```{r walkthrough-21}\\nlast_plot() +\\n    aes(fill = ifelse(Sex == \\\"Female\\\" | Age == \\\"Child\\\", \\\"Female or Child\\\", \\\"Male Adult\\\")) \\n```\\n:::\\n\"           \n\n\nOkay, ready for the closeread demonstration! (Comparing flipbookr/xaringan implementation what we are doing here, there’s probably greater focus on narration.) We’ll use knitr::knit() inline to get this done - paste(knitr::knit(text = to_closeread, quiet = F), collapse = \"\\n\\n\")\n\n\n\n\nOk Lets look at this titanic data, using ggplot(data = titanic_wide)\n\n\n\n\nHere some variables of interest, using aes(y = Freq, axis1 = Sex, axis2 = Survived)\n\n\n\n\nin a alluvial plot first look, using ggchalkboard:::theme_slateboard(base_size = 18)\n\n\n\n\nAnd we are ready to look at flow, using geom_alluvium()\n\n\n\n\nAnd we can label our stratum axes, using geom_stratum(aes(fill = NULL))\n\n\n\n\nAdd stratum labels, using geom_stratum_text()\n\n\n\n\nlook at age to survival, using aes(axis1 = Age)\n\n\n\n\nlook at class to survival, using aes(axis1 = Class)\n\n\n\n\nage to class to survival, using aes(axis1 = Age, axis2 = Class, axis3 = Survived)\n\n\n\n\na train, using aes(axis1 = Sex, axis2 = Age, axis3 = Class, axis4 = Survived)\n\n\n\n\nTrack sex throughout, using aes(fill = Sex)\n\n\n\n\nremove fill guide as axis1 is labeled, using guides(fill = \"none\")\n\n\n\n\nadjusting the x axis, using scale_x_discrete(limits = c(\"Sex\", \"Age\", \"Class\", \"Survived\"), expand = c(.1, .1))\n\n\n\n\nAn overall label for x axis, using labs(x = \"Demographic\")\n\n\n\n\nadding a caption , using labs(caption = \"Passengers on the maiden voyage of the Titanic\")\n\n\n\n\nminimize flow crossing, using aes(axis1 = fct_rev(Sex))\n\n\n\n\nminimize flow crossing, using aes(axis4 = fct_rev(Survived))\n\n\n\n\nremove Age, using aes(axis2 = NULL)\n\n\n\n\nReplace axis 1, using aes(axis1 = ifelse(Sex == \"Female\" | Age == \"Child\", \"Female or Child\", \"Male Adult\"))\n\n\n\n\nadjusting the x axis, using scale_x_discrete(limits = c(\"Sex & Age\", \"Class\", \"Survived\"), expand = c(.2, .1))\n\n\n\n\nMore , using aes(fill = ifelse(Sex == \"Female\" | Age == \"Child\", \"Female or Child\", \"Male Adult\"))\n\n\n\n\n\n\n\n  ggplot(data = titanic_wide) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(y = Freq, axis1 = Sex, axis2 = Survived) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    ggchalkboard:::theme_slateboard(base_size = 18) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_alluvium() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_stratum(aes(fill = NULL)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_stratum_text() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(axis1 = Age) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(axis1 = Class) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(axis1 = Age, axis2 = Class, axis3 = Survived) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(axis1 = Sex, axis2 = Age, axis3 = Class, axis4 = Survived) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(fill = Sex) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    guides(fill = \"none\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    scale_x_discrete(limits = c(\"Sex\", \"Age\", \"Class\", \"Survived\"), expand = c(.1, .1)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    labs(x = \"Demographic\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    labs(caption = \"Passengers on the maiden voyage of the Titanic\") \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(axis1 = fct_rev(Sex)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(axis4 = fct_rev(Survived)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(axis2 = NULL) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(axis1 = ifelse(Sex == \"Female\" | Age == \"Child\", \"Female or Child\", \"Male Adult\")) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n      scale_x_discrete(limits = c(\"Sex & Age\", \"Class\", \"Survived\"), expand = c(.2, .1)) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(fill = ifelse(Sex == \"Female\" | Age == \"Child\", \"Female or Child\", \"Male Adult\"))"
  }
]