[
  {
    "objectID": "closereads-chunk-reveal.html",
    "href": "closereads-chunk-reveal.html",
    "title": "My First Closeread",
    "section": "",
    "text": "ggplot2 allows you build up your plot bit by bit â€“ to write â€˜graphical poemsâ€™ (Wickham 2010). It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.\nHere is a graphical poem!\n\nggplot(data = cars) + # The first declaration you typically make is the dataframe to plot\n  aes(x = speed, y = dist) + # The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance)\n  geom_point() + # Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples)\n  geom_smooth() # Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) \n\n\n\n\n\n\n\n\nCloseread helps walk people through and digest ideas suggesting a synergy with the gg world. With Closereads, maybe we can read this graphical poem â€˜aloudâ€™, and reflect on it a bit in plain language as we go. Here is a generic way to write out what closereads requires for creating plot output and referring to it.\n\ncr_last_plot_construction &lt;- ':::{focus-on=\"cr-.PLOTXXX\"}\\n.COMMENT, using `.CODE`\\n:::\\n\\n:::{#cr-.PLOTXXX}\\n```{r .PLOTXXX}\\n.LEADING\\n  .CODE\\n```\\n:::\\n'  \n\ncr_last_plot_construction |&gt; cat()\n\n:::{focus-on=\"cr-.PLOTXXX\"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n\n\nThen we can look at our complete â€˜graphical poemâ€™, parse it, choreograph a line by line reveal - thanks Garrick and Emi for showing the way using powerful knitr::knit_code$get in Xaringan context! https://emitanaka.rbind.io/post/knitr-knitr-code/ At this point we arenâ€™t being really careful with code parsing or replacement; flipbookr internals has some nicer parsing that might be useable and allow more incremental reveals in other contexts like datamanipulation and table creation. In contrast to the full reiterated code that we show in flipbookr w/ Xaringan w/ plot, weâ€™ll use last_plot() + new_code() below. It just feels like a better fit.\n\nknitr::knit_code$get(\"walkthrough\") |&gt;\n  tibble(code_raw = _) |&gt;\n  mutate(comment = str_extract(code_raw, \"#.+$\")) |&gt;\n  mutate(comment = str_remove(comment, \"#\")) |&gt;\n  mutate(code = str_remove(code_raw, \"\\\\+ #.+$|#.+$\")) |&gt;\n  mutate(index = row_number()) |&gt;\n  mutate(plot_name = paste(\"walkthrough\", sep = \"-\", index)) |&gt;\n  mutate(to_cr = cr_last_plot_construction) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".PLOTXXX\", plot_name)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".COMMENT\", comment)) |&gt;\n  mutate(to_cr = str_replace_all(to_cr, \".CODE\", code)) |&gt;\n  mutate(to_cr = str_replace(to_cr, \".LEADING\", ifelse(index == 1, \"\", \"last_plot() +\"))) |&gt;\n  pull(to_cr) -&gt; \nto_closeread\n\nto_closeread\n\n[1] \":::{focus-on=\\\"cr-walkthrough-1\\\"}\\n The first declaration you typically make is the dataframe to plot, using `ggplot(data = cars) `\\n:::\\n\\n:::{#cr-walkthrough-1}\\n```{r walkthrough-1}\\n\\n  ggplot(data = cars) \\n```\\n:::\\n\"                                                                                                           \n[2] \":::{focus-on=\\\"cr-walkthrough-2\\\"}\\n The second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using `  aes(x = speed, y = dist) `\\n:::\\n\\n:::{#cr-walkthrough-2}\\n```{r walkthrough-2}\\nlast_plot() +\\n    aes(x = speed, y = dist) \\n```\\n:::\\n\" \n[3] \":::{focus-on=\\\"cr-walkthrough-3\\\"}\\n Then you'll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using `  geom_point() `\\n:::\\n\\n:::{#cr-walkthrough-3}\\n```{r walkthrough-3}\\nlast_plot() +\\n    geom_point() \\n```\\n:::\\n\"                             \n[4] \":::{focus-on=\\\"cr-walkthrough-4\\\"}\\n Finally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using `  geom_smooth() `\\n:::\\n\\n:::{#cr-walkthrough-4}\\n```{r walkthrough-4}\\nlast_plot() +\\n    geom_smooth() \\n```\\n:::\\n\"\n\n\nOkay, ready for the closeread demonstration! (Comparing flipbookr/xaringan implementation what we are doing here, thereâ€™s probably greater focus on narration.) Weâ€™ll use knitr::knit() inline to get this done - paste(knitr::knit(text = to_closeread, quiet = F), collapse = \"\\n\\n\")\n\n\n\n\nThe first declaration you typically make is the dataframe to plot, using ggplot(data = cars)\n\n\n\n\nThe second declaration is what visual channels should represent which variables (here x and y position are used to represent speed and distance), using aes(x = speed, y = dist)\n\n\n\n\nThen youâ€™ll specify the mark (point here) that will take on the aesthetics (x or y position here, but color, size, shape are other examples), using geom_point()\n\n\n\n\nFinally we might be interested in making some predictions; what is the expected value (mean) of y given some x (here stopping distance given some speed upon breaking) , using geom_smooth()\n\n\n\n\n\n\n\n  ggplot(data = cars) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    aes(x = speed, y = dist) \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_point() \n\n\n\n\n\n\n\n\n\n\n\nlast_plot() +\n    geom_smooth()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Everyday ggplot2 extension: sublayer modularity ðŸ«–",
    "section": "",
    "text": "Welcome to ggplot2 extenders/ggplot2 extension club. This forum exists to facilitate conversations about experiences with extension. We like to talk about motivations, challenges, equivocations â€” in general, extension journeys!\nOur main activities are meetings and discussions.\nInterested in joining us? Please leave your contact info here and let us know a little about your interest in ggplot2 extension so we can be in touch!\nNote that the extension ecosystem is extensive and other initiatives exist to support extenders, check out some other resources."
  },
  {
    "objectID": "ggplot2-sublayer-modularity.html",
    "href": "ggplot2-sublayer-modularity.html",
    "title": "ggplot2 sublayer modularity",
    "section": "",
    "text": "If you are a fan of ggplot2, you are probably also a fan of â€˜layerâ€™ functions geom_*() and stat_*().\nSidenote: Sometimes all the ggplot2 functions are referred to as ggplot2 layers scales_*(), coord_*(), etc. You often hear things like â€˜build up your plot layer-by-layerâ€™ but we are using the word in the narrower, original sense.\n\n\n\n\nMaybe you get giddy thinking about geom_bump(), geom_ridgeline(), or classic geom_histogram()?\n\n\n\n\nWell-composed geom_*()s and stat_*()s (i.e.Â layer) make for more fluid analytic discovery.\n\n\n\n\nBut what elements constitute a layer function?\n\n\n\n\nLetâ€™s look at geom_bar() to get a feel for what layer composition means.\nIn this plot specification, geom_bar() counts the number of observations that are of each value of x (cut).\n\n\n\n\nThere are actually three main characters in every geom_() or stat_().\n\n\n\n\nThey are geom, stat, and position.\n\n\n\n\nIn geom_bar() the geom is fixed, but stat and position are adjustable. You can see that their defaults are \"count\" and \"stack\" in the functionâ€™s definition.\n\n\n\n\nAnd instead of using convenient geom_bar(), we can use the more generic layer() function - which is actually used under the hood to define all geom_*() and stat_*() functions.\n\n\n\n\nWe can reproduce `geom_bar()`â€˜s behavior with layer(), but we must provide all three â€™control operatorsâ€™:layer(geom = \"bar\", stat = \"count\", position = \"stack\").\n\n\n\n\nOr, equivalently, we can simply name the underlying ggproto objects, GeomBar and StatCount in our case, and the position function, position_stack() .\n\n\n\n\nReiteration: There are actually â€˜control operatorsâ€™ that define the geom_*() and stat_*() user-facing function. Geoms, Stats, and position_*().\n\n\n\n\nYou can refer to them indirectly by quoting their stem, layer(geom = \"bar\", stat = \"count\", position = \"stack\").\n\n\n\n\nOr use the ggproto objects and position function directly, layer(geom = GeomBar, stat = StatCount, position = position_stack())\n\n\n\n\nFocus: Lets look at one â€˜control operatorâ€™, the Stat, more closely.\n\n\n\n\nStats themselves have a number of control elements.\n\n\n\n\nIt transforms plot input data before it is passed off to be rendered.\nStatâ€™s computation is defined in the compute slots.\nAnd in StatCount, compute is done group-wise, so compute_group() defines StatCountâ€™s data transformation.\n\n\n\n\n\nStatCount$compute_group\n\n&lt;ggproto method&gt;\n  &lt;Wrapper function&gt;\n    function (...) \ncompute_group(..., self = self)\n\n  &lt;Inner function (f)&gt;\n    function (self, data, scales, width = NULL, flipped_aes = FALSE) \n{\n    data &lt;- flip_data(data, flipped_aes)\n    x &lt;- data$x\n    weight &lt;- data$weight %||% rep(1, length(x))\n    count &lt;- as.vector(rowsum(weight, x, na.rm = TRUE))\n    bars &lt;- data_frame0(count = count, prop = count/sum(abs(count)), \n        x = sort(unique0(x)), width = width, flipped_aes = flipped_aes, \n        .size = length(count))\n    flip_data(bars, flipped_aes)\n}\n\n\n\n\n\n\nWe can get a sense of StatCount$compute_groupâ€™s behavior by using on our data.\nFirst, we use select() to make the data look as it would inside of the ggplot2 plotting environment â€” this mirrors the aes(x = cut) mapping declaration.\nThen we see that the data is collapsed by x, and count and prop variables are produced.\n\n\n\n\nWe can think about StatCountâ€™s job as doing some computation that the user might otherwise be responsible for.\n\n\n\n\nWe use StatCount$compute_group() to manually do this computation for us, in conjunction with StatIdentity (leaves data alone) in layer to show this work explicitly.\n\n\n\n\nKey point: We might think Statâ€™s job as lightening the analystâ€™s load - doing computation that the user would otherwise need to do for before plotting.\n\n\n\n\nOne final question you might have is â€™how exactly is the height of the bar, y, communicated to the ggplot2 system? Why does that just work?\n\n\n\n\nThis is managed by the default_aes specification for StatCount.\nBecause there is no variable mapped to y in our plot specification, y position defaults to after_stat(count), in other words the computed variable count that results from the StatCount computation!\n\n\n\n\nAnd it is good to do a little mix-and-match thinking to get a further feel for StatCount. Which of the following plots will have identical outputs?\n\n\n\n\nIs this what you anticipated?\n\n\n\n\nAbove, weâ€™ve had an outside-in look at some aspects of â€˜sublayer modularityâ€™.\nTo get an inside-out look â€” building up your own Stat from scratch â€” you might have a look at â€˜easy geom recipesâ€™ or by joining ggplot2 extenders club\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_bar\n\nfunction (mapping = NULL, data = NULL, stat = \"count\", position = \"stack\", \n    ..., just = 0.5, na.rm = FALSE, orientation = NA, show.legend = NA, \n    inherit.aes = TRUE) \n{\n    layer(data = data, mapping = mapping, stat = stat, geom = GeomBar, \n        position = position, show.legend = show.legend, inherit.aes = inherit.aes, \n        params = list2(just = just, na.rm = na.rm, orientation = orientation, \n            ...))\n}\n&lt;bytecode: 0x7fa6a2ab4d48&gt;\n&lt;environment: namespace:ggplot2&gt;\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  layer(geom = \"bar\", stat = \"count\", position = \"stack\")\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2) \nggplot(diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, stat = StatCount, position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatCount |&gt; names()\n\n[1] \"default_aes\"   \"extra_params\"  \"super\"         \"compute_group\"\n[5] \"required_aes\"  \"setup_params\"  \"dropped_aes\"  \n\n\n\n\n\nlibrary(dplyr)\n\ndiamonds |&gt; \n  select(x = cut) |&gt;\n  StatCount$compute_group() \n\n  count       prop         x flipped_aes\n1  1610 0.02984798      Fair       FALSE\n2  4906 0.09095291      Good       FALSE\n3 12082 0.22398962 Very Good       FALSE\n4 13791 0.25567297   Premium       FALSE\n5 21551 0.39953652     Ideal       FALSE\n\n\n\n\n\nprecomputation &lt;- diamonds |&gt; \n  select(x = cut) |&gt;\n  StatCount$compute_group()\n\nprecomputation |&gt;\n  ggplot() + \n  aes(x = x, y = count) + \n  layer(geom = GeomBar, \n        stat = StatIdentity, \n        position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatCount$default_aes\n\nAesthetic mapping: \n* `x`      -&gt; `after_stat(count)`\n* `y`      -&gt; `after_stat(count)`\n* `weight` -&gt; 1\n\nggplot(data = diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, \n        stat = StatCount, \n        position = position_stack())\n\n\n\n\n\n\n\n\n\n\n\np1 &lt;- ggplot(data = diamonds) + \n  aes(x = cut) + \n  layer(geom = GeomBar, \n        stat = StatCount, \n        position = position_stack())\n\np2 &lt;- p1 + geom_point(stat = StatCount)\n\np3 &lt;- p1 + stat_count(geom = GeomPoint)\n\np4 &lt;- p1 + geom_label(stat = StatCount, \n                      aes(label = after_stat(count)))\n\np5 &lt;- p1 + stat_count(geom = GeomText, \n                      aes(label = after_stat(count)), \n                      vjust = 1)\n\n\n\n\nlibrary(patchwork)\np2+ p3 + p4 + p5"
  }
]