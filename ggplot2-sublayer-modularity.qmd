---
title: "ggplot2 sublayer modularity"
subtitle: "a brief, gentle and fun first-look behind the curtains. "
format: closeread-html
---

```{r,include=F}
library(tidyverse)
cars <- tibble(cars)
knitr::opts_chunk$set(echo = T, message = F, warning = F)
```



::: cr-section
::: {focus-on="cr-PLOT000"}
If you are a fan of ggplot2, you are probably also a fan of 'layer' functions: `geom_*` and `stat_*` functions.
:::

::: {#cr-PLOT000}
![](images/clipboard-1589230205.png)
:::

::: {focus-on="cr-PLOT00"}
Maybe you are giddy when you think about `geom_bump`? Do you love to layer on a good `geom_ridgelines`? Is rendering classic `geom_histogram` just kind of exciting?
:::

::: {#cr-PLOT00}
![](images/clipboard-1637685515.png)
:::

::: {focus-on="cr-PLOT0"}
Well-composed layers, (choice in sublayer modules) affords greater fluidity for ggplot2 users and faster analytic discovery. But what elements constitute a layer function?
:::

::: {#cr-PLOT0}
![](images/clipboard-506665849.png)
:::

::: {focus-on="cr-PLOT1"}
Let's look at `geom_bar()` composition to get a feel for what layer composition means.
:::

::: {#cr-PLOT1}
```{r PLOT1}
library(ggplot2) 
ggplot(diamonds) + 
  aes(x = cut) + 
  geom_bar()
```
:::

::: {focus-on="cr-PLOT2a"}
You might be aware that controlling each layer are three main elements. We can express the layer `geom_bar()` in terms of the component elements too using the `layer()` function ... we can translate `geom_bar()` to `layer(geom = "bar", stat = "count", position = "stack")`
:::

::: {#cr-PLOT2a}
```{r PLOT2a}
library(ggplot2) 
ggplot(diamonds) + 
  aes(x = cut) + 
  layer(geom = "bar", stat = "count", position = "stack")
```
:::

::: {focus-on="cr-PLOT2c"}
Or we can simply name the `ggproto` object or function which the quoted text in the variant above refers too: `GeomBar`, `StatCount`, and `position_stack()` are at work in the default settings for geom_bar().
:::

::: {#cr-PLOT2c}
```{r PLOT2b}
library(ggplot2) 
ggplot(diamonds) + 
  aes(x = cut) + 
  layer(geom = GeomBar, stat = StatCount, position = position_stack())
```
:::

::: {focus-on="cr-PLOT2b"}
Main point: *There are three main 'control operators' for every layer call: `geom`, `stat`, and `position`. You can refer to them indirectly by quoting their stem, `layer(geom = "bar", stat = "count", position = "stack")`, or use them directly, `layer(geom = GeomBar, stat = StatCount, position = position_stack())`*
:::

::: {#cr-PLOT2b}
![](images/clipboard-309178775.png)
:::

::: {focus-on="cr-PLOT2d"}
Focus: *Lets look at the second 'control operator' Stat, more closely.*
:::

::: {#cr-PLOT2d}
![](images/clipboard-1390047241.png)
:::

::: {focus-on="cr-PLOT2e"}
Stats themselves have a number of control elements.
:::

::: {#cr-PLOT2e}
![](images/clipboard-2172743515.png)


<!-- ```{r PLOT2e} -->
<!-- StatCount -->
<!-- ``` -->

:::

::: {focus-on="cr-PLOT2f"}
Critically, it can transform input plot input data before it is passed off to be rendered. Compute is defined in the compute slots, and in `StatCount`, compute is done group-wise, so `compute_group()` defines StatCount's data transformation.
:::

::: {#cr-PLOT2f}
```{r PLOT2f}
StatCount$compute_group
```
:::


::: {focus-on="cr-PLOT3"}
We can get a sense of `StatCount$compute_group`'s behavior by using on our data. First, we use `select()` to make the data look as it would inside of the ggplot2 plotting environment. Then we see that the data is collapsed by `x`, and `count` and `prop` variables are produced.
:::

::: {#cr-PLOT3}
```{r PLOT3}

library(dplyr)

diamonds |> 
  select(x = cut) |>
  StatCount$compute_group() 
```
:::

::: {focus-on="cr-PLOT4"}
We can think about StatCount's job as doing some pre-computation that the user might otherwise be responsible for. We use StatCount\$compute_group() to manually do this computation for us, in conjunction with StatIdentity in `layer` (leaves data alone) to explicitly show this work.
:::

::: {#cr-PLOT4}
```{r PLOT4}
precomputation <- diamonds |> 
  select(x = cut) |>
  StatCount$compute_group()

precomputation |>
  ggplot() + 
  aes(x = x, y = count) + 
  layer(geom = GeomBar, 
        stat = StatIdentity, 
        position = position_stack())
```
:::

::: {focus-on="cr-PLOT4.2"}
Key point: We might think Stat's job as doing heavy lifting - some pre-computation that the user might otherwise be responsible for.
:::


::: {#cr-PLOT4.2}
![](images/clipboard-3717409450.png)
:::


::: {focus-on="cr-PLOT4.3"}
One final question you might have is 'how do we get the height of the bar, `y`? Why does that 'just work'?
:::


::: {#cr-PLOT4.3}
![](images/clipboard-482897444.png)
:::

::: {focus-on="cr-PLOT5"}
This is managed by the `default_aes` specification for StatCount. Because there is no variable mapped to y in our plot specification, y position default to after_stat(count), the `count` variable that results from the StatCount computation.
:::

::: {#cr-PLOT5}
```{r PLOT5}
StatCount$default_aes

ggplot(data = diamonds) + 
  aes(x = cut) + 
  layer(geom = GeomBar, 
        stat = StatCount, 
        position = position_stack())
```
:::

::: {focus-on="cr-PLOT5bb"}
And it is good to do a little mix and match thinking to get a further feel for StatCount. Which of the following plots will have identical outputs?
:::

::: {#cr-PLOT5bb}
```{r PLOT5bb}
p1 <- ggplot(data = diamonds) + 
  aes(x = cut) + 
  layer(geom = GeomBar, 
        stat = StatCount, 
        position = position_stack())

p2 <- p1 + geom_point(stat = StatCount)

p3 <- p1 + stat_count(geom = GeomPoint)

p4 <- p1 + geom_label(stat = StatCount, 
                      aes(label = after_stat(count)))

p5 <- p1 + stat_count(geom = GeomText, 
                      aes(label = after_stat(count)), 
                      vjust = 1)
```
:::

::: {focus-on="cr-PLOT5c"}
Is this what you anticipated?
:::

::: {#cr-PLOT5c}
```{r PLOT5c}
library(patchwork)
p2+ p3 + p4 + p5
```
:::

::: {focus-on="cr-PLOT6"}
Above, we've had an *outside*-in look at some aspects of 'sublayer modularity'. To get an *inside*-out look -- building up your own Stat -- you might have a look at ['easy geom recipes'](https://evamaerey.github.io/easy-geom-recipes/) or by joining [ggplot2 extenders club](https://teunbrand.github.io/ggplot-extension-club/)
:::

::: {#cr-PLOT6}
![](images/clipboard-3862730267.png)
:::


:::
