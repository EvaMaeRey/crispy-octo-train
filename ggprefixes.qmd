---
title: Who are the ggplot2 extenders?
format: closeread-html
---


```{r, include = F}
library(tidyverse)
knitr::opts_chunk$set(echo = T, message = F, warning = F)
```



```{r}
user_repo_fun <- read_csv("https://raw.githubusercontent.com/EvaMaeRey/mytidytuesday/refs/heads/main/2024-11-19-gg-prefixes/exported_funs_exts_ggplot2_tidyverse_org.csv") %>% 
  mutate(prefix_short = fun_exported |> str_extract(".*?_")) %>% 
  mutate(prefix_long = fun_exported |> str_extract(".+_"))

sample_n(user_repo_fun, 10)
```

```{r}
data_filter <- function(.keep, .by) {
  structure(list(keep_specification = rlang::enquo(.keep), 
                 by_specification = rlang::enquo(.by)), 
            class = "filterobs")
}

ggplot_add.filterobs <- function(object, plot, object_name) {
  
  new_data <- dplyr::filter(plot$data, 
                            !!object$keep_specification, 
                            .by = !!object$by_specification)
  plot$data <- new_data
  plot

}

```



ggplot2 allows you build up your plot bit by bit -- to write 'graphical poems' (Wickham 2010).  It is easy to gain insights simply by 1. defining a data set to look at, 2. the aesthetics (x position, y position, color, size, etc) that should represent variables from that data, and 3. what geometric marks should take on those aesthetics. Inspired by this incrementalism, frameworks like camcorder, flipbookr, codehover exist to capture plot composition.







```{r, echo = F}
cr_last_plot_construction <- ':::{focus-on="cr-.PLOTXXX"}\n.COMMENT, using `.CODE`\n:::\n\n:::{#cr-.PLOTXXX}\n```{r .PLOTXXX}\n.LEADING\n  .CODE\n```\n:::\n'  

cr_last_plot_construction |> cat()
```



```{r, include = F}
knitr::knit_code$get("walkthrough") |>
  tibble(code_raw = _) |>
  mutate(comment = str_extract(code_raw, "#.+$")) |>
  mutate(comment = str_remove(comment, "#")) |>
  mutate(code = str_remove(code_raw, "\\+ #.+$|#.+$")) |>
  mutate(index = row_number()) |>
  mutate(plot_name = paste("walkthrough", sep = "-", index)) |>
  mutate(to_cr = cr_last_plot_construction) |>
  mutate(to_cr = str_replace_all(to_cr, ".PLOTXXX", plot_name)) |>
  mutate(to_cr = str_replace(to_cr, ".COMMENT", comment)) |>
  mutate(to_cr = str_replace_all(to_cr, ".CODE", code)) |>
  mutate(to_cr = str_replace(to_cr, ".LEADING", ifelse(index == 1, "", "last_plot() +"))) |>
  pull(to_cr) -> 
to_closeread

to_closeread
```






:::{.cr-section}

`r paste(knitr::knit(text = to_closeread, quiet = F), collapse = "\n\n")`

:::


```{r}
last_plot()$plot_data
```

Here is the complete graphical poem!

```{r walkthrough, echo = T}
ggplot(data = user_repo_fun) + # the data frame to be plotted is all the exported functions from the 
  aes(id = "All exported\n functions") + # let's look at a count of all the exported functions first
  ggcirclepack::geom_circlepack() + # Using circlepacking, we automatically have circles size representing the number of observation, i.e. exported functions
  ggcirclepack::geom_circlepack_text() + # Of course this is hard to interpret without some kind of label.  We use geom_circplepack_text to do this for us
  ggchalkboard:::theme_glassboard() + # we'll add a theme
  theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) + # And remove axes... 
  coord_equal() + # and lets square up the circles
  aes(id = repo) + # First we ask what packages - github repository names - are present
  aes(id = user) + # Then let's look at who is writing these exported functions
  aes(id = prefix_short) + # And we can look at what types of functions are exported, by looking at prefixes
  aes(id = prefix_long) + # Disaggregating a little, to longer prefixes like scale_color, we get a more granular look at exported function types
  data_filter(n() > 60 & !is.na(prefix_long), .by = prefix_long) + # and we filter more popular prefixes
  facet_wrap(~prefix_long) + # and break up our plot space by these prefixes
  data_filter(prefix_long != "gf_") + #gf isn't really a in-grammar prefix
  aes(id = user) + # let's look at top prefixes by user
  data_filter(n() >= 10, .by = c(user, prefix_long)) # and look at the prolific authors in each of these areas
```
